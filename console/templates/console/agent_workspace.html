{% extends "console_page.html" %}
{% load static %}
{% load agent_extras %}

{% block console_content %}
<div class="space-y-6">
  <header class="bg-white/80 backdrop-blur-sm shadow-xl rounded-xl overflow-hidden">
    <div class="px-6 py-4">
      <h1 class="text-xl font-semibold text-gray-800">Conversation with {{ agent.name }}</h1>
    </div>
  </header>

  <div id="agent-workspace-root"
       class="flex h-full flex-col gap-6"
       data-timeline-limit="{{ timeline_limit }}"
       data-timeline-newer-url="{{ timeline_newer_url }}"
       data-timeline-older-url="{{ timeline_older_url }}"
       data-event-stream-url="{{ event_stream_url }}">

    <div id="timeline-events" class="flex h-full flex-col gap-3 overflow-y-auto">
      <div class="flex justify-center py-2 text-xs text-slate-500">
        {% if timeline_window.has_more_older %}
          <button
            class="inline-flex items-center gap-2 rounded-full border border-gray-200 bg-white px-3 py-1.5 text-xs font-medium text-gray-600 shadow-sm hover:bg-gray-50"
            hx-get="{{ timeline_older_url }}{% if timeline_window.window_oldest_cursor %}&cursor={{ timeline_window.window_oldest_cursor|urlencode }}{% endif %}&limit={{ timeline_limit }}&current_newest={{ timeline_window.window_newest_cursor|default:''|urlencode }}"
            hx-target="#timeline-events"
            hx-swap="afterbegin">
            Load older
          </button>
        {% endif %}
      </div>
      {% include "console/partials/_agent_timeline_items.html" with events=timeline_window.events %}
    </div>

    <div id="timeline-cursors" class="hidden"
         data-older="{{ timeline_window.window_oldest_cursor|default:'' }}"
         data-newer="{{ timeline_window.window_newest_cursor|default:'' }}"
         data-has-more-older="{{ timeline_window.has_more_older|yesno:'true,false' }}"
         data-has-more-newer="{{ timeline_window.has_more_newer|yesno:'true,false' }}"></div>

    <button id="jump-to-latest"
            class="hidden absolute bottom-20 left-1/2 z-20 -translate-x-1/2 rounded-full border border-gray-200 bg-white px-3 py-1 text-xs font-semibold text-indigo-600 shadow-lg"
            type="button">
      Jump to latest
    </button>

    <div class="bg-white/80 backdrop-blur-sm shadow-xl rounded-xl overflow-hidden p-4">
      <form id="agent-web-compose" class="flex flex-col gap-3" hx-post="{% url 'agent_web_message' agent.id %}" hx-swap="none">
      <textarea name="body" rows="3" required
                class="w-full resize-none rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                placeholder="Send a message..."></textarea>
      <div class="flex items-center justify-between">
        <p class="text-xs text-gray-500">Markdown supported. Shift + Enter for newline.</p>
        <button type="submit"
                class="inline-flex items-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
          Send
        </button>
      </div>
        <input type="hidden" name="current_newest" id="composer-latest-cursor" value="{{ timeline_window.window_newest_cursor|default:'' }}">
      </form>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Prism.js for SQL syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script>
(function () {
  if (window.__agentWorkspaceInitialized) {
    console.debug('[agent-workspace] script already initialized; skipping');
    return;
  }
  window.__agentWorkspaceInitialized = true;

  const root = document.getElementById('agent-workspace-root');
  const log = (...args) => console.debug('[agent-workspace]', ...args);

  if (!root) {
    console.warn('[agent-workspace] root node missing; aborting init.');
    return;
  }

  let attempts = 0;
  const MAX_ATTEMPTS = 20;
  let initialized = false;

  function ready() {
    if (typeof window.htmx === 'undefined') {
      attempts += 1;
      log('htmx wait attempt', { attempts });
      if (attempts === 1) {
        console.warn('[agent-workspace] htmx not yet available; retrying init.');
      }
      if (attempts > MAX_ATTEMPTS) {
        console.error('[agent-workspace] htmx failed to load after retries; realtime disabled.');
        return false;
      }
      window.setTimeout(ready, 150);
      return false;
    }

    log('initializing workspace timeline', { dataset: { newerUrl: root.dataset.timelineNewerUrl, olderUrl: root.dataset.timelineOlderUrl, eventStreamUrl: root.dataset.eventStreamUrl } });
    init();
    return true;
  }

  function init() {
    if (initialized) {
      log('init called after initialization; skipping');
      return;
    }
    initialized = true;

  const timeline = document.getElementById('timeline-events');
  const composer = document.getElementById('agent-web-compose');
  const composerCursor = document.getElementById('composer-latest-cursor');
  const getCursorsEl = () => document.getElementById('timeline-cursors');

  const limit = parseInt(root.dataset.timelineLimit || '150', 10);
  const newerUrl = root.dataset.timelineNewerUrl;
  const eventStreamUrl = root.dataset.eventStreamUrl;

  const state = {
    action: 'idle',
    previousScrollHeight: 0,
    lastEventId: null,
    pendingComposerScroll: false,
    autoScroll: true,
    eventSource: null,
  };

  let reconnectDelay = 3000;
  const RECONNECT_MAX = 30000;

  function isNearBottom() {
    if (!timeline) return true;
    const threshold = 48;
    return timeline.scrollHeight - timeline.scrollTop - timeline.clientHeight <= threshold;
  }

  function scrollToBottom(force) {
    if (!timeline) return;
    if (force || isNearBottom()) {
      timeline.scrollTop = timeline.scrollHeight;
    }
  }

  function updateComposerCursor() {
    const cursorNode = getCursorsEl();
    if (composerCursor && cursorNode) {
      composerCursor.value = cursorNode.dataset.newer || '';
    }
  }

  function updateJumpButton() {
    const btn = document.getElementById('jump-to-latest');
    if (!btn) return;
    const cursorNode = getCursorsEl();
    const hasMoreNewer = cursorNode?.dataset.hasMoreNewer === 'true';
    if (!hasMoreNewer || isNearBottom()) {
      btn.classList.add('hidden');
      return;
    }
    btn.classList.remove('hidden');
  }

  function trimTimeline(direction) {
    if (!timeline) return;
    const items = timeline.querySelectorAll('.timeline-event');
    if (items.length <= limit) return;
    const excess = items.length - limit;
    log('trimming timeline', { direction, excess });
    if (direction === 'older') {
      for (let i = 0; i < excess; i += 1) {
        const node = items[items.length - 1 - i];
        if (node) node.remove();
      }
    } else {
      for (let i = 0; i < excess; i += 1) {
        const node = items[i];
        if (node) node.remove();
      }
    }
  }

  function requestNewer(trigger) {
    if (!newerUrl || !timeline) return;
    const params = new URLSearchParams({ limit: String(limit) });
    const cursorNode = getCursorsEl();
    const cursor = cursorNode?.dataset.newer;
    if (cursor) params.set('cursor', cursor);

    state.action = 'newer';
    state.autoScroll = state.pendingComposerScroll ? true : trigger !== 'auto-newer' ? true : isNearBottom();

    log('requestNewer', { trigger, cursor, autoScroll: state.autoScroll });

    window.htmx.ajax('GET', `${newerUrl}&${params.toString()}`, {
      target: '#timeline-events',
      swap: 'beforeend',
    });
  }

  if (timeline) {
    timeline.addEventListener('scroll', () => {
      state.autoScroll = isNearBottom();
      log('scroll', { autoScroll: state.autoScroll });
      updateJumpButton();
    });
  }

  document.addEventListener('click', (event) => {
    const btn = event.target.closest('#jump-to-latest');
    if (!btn) return;
    log('jump-to-latest clicked');
    scrollToBottom(true);
    state.autoScroll = true;
    btn.classList.add('hidden');
  });

  if (composer) {
    composer.addEventListener('htmx:beforeRequest', () => {
      state.pendingComposerScroll = true;
      log('composer submit start');
    });
    composer.addEventListener('htmx:afterRequest', (event) => {
      if (event.detail && event.detail.xhr && event.detail.xhr.status < 400) {
        composer.reset();
        log('composer submit success');
      } else {
        state.pendingComposerScroll = false;
        log('composer submit error', event.detail?.xhr?.status);
      }
    });
  }

  window.htmx.on('htmx:beforeRequest', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;
    const url = event.detail.requestConfig?.path || '';
    log('htmx beforeRequest', { url });
    if (url.includes('direction=older')) {
      state.action = 'older';
      state.previousScrollHeight = timeline?.scrollHeight || 0;
    } else if (url.includes('direction=newer')) {
      state.action = 'newer';
    }
  });

  window.htmx.on('htmx:afterSwap', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;

    log('htmx afterSwap', { action: state.action, autoScroll: state.autoScroll });

    if (state.action === 'older' && timeline) {
      const delta = timeline.scrollHeight - state.previousScrollHeight;
      timeline.scrollTop = Math.max(delta, 0);
    }

    trimTimeline(state.action);
    updateComposerCursor();

    // Highlight any new code blocks
    if (typeof Prism !== 'undefined') {
      Prism.highlightAllUnder(timeline);
    }

    if (state.autoScroll) {
      log('auto-scroll applied');
      scrollToBottom(true);
    }

    state.action = 'idle';
    state.previousScrollHeight = 0;
    state.pendingComposerScroll = false;
    state.autoScroll = isNearBottom();
    updateJumpButton();
  });

  window.htmx.on('htmx:afterSettle', (event) => {
    if (event.detail?.target?.id === 'timeline-events') {
      log('htmx afterSettle');
      updateJumpButton();
    }
  });

  function connectEventStream(lastId) {
    if (!eventStreamUrl) {
      console.warn('[agent-workspace] Missing eventStreamUrl dataset attribute; realtime updates disabled.');
      return;
    }

    if (typeof window.EventSource === 'undefined') {
      console.warn('[agent-workspace] EventSource API unavailable; realtime updates disabled.');
      return;
    }

    let cursor = lastId;
    if (cursor && !/^[0-9]+-[0-9]+$/.test(cursor)) {
      log('invalid_last_event_id_format', { cursor });
      cursor = null;
    }

    const url = cursor ? `${eventStreamUrl}?cursor=${encodeURIComponent(cursor)}` : eventStreamUrl;
    log('connecting SSE', { url, cursor });
    const source = new EventSource(url);

    source.onopen = () => {
      log('SSE open');
    };

    const handleMessage = (evt) => {
      if (evt.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      log('SSE message', { event: evt.type || 'message', lastId: evt.lastEventId });
      requestNewer('auto-newer');
    };

    source.addEventListener('message', handleMessage);
    source.addEventListener('step.created', handleMessage);
    source.addEventListener('message.created', handleMessage);
    source.onerror = (err) => {
      log('SSE error', err);
      source.close();
      state.eventSource = null;
      reconnectDelay = Math.min(Math.round(reconnectDelay * 1.5), RECONNECT_MAX);
      log('SSE reconnect scheduled', reconnectDelay);
      window.setTimeout(() => connectEventStream(state.lastEventId), reconnectDelay);
    };

    state.eventSource = source;
  }

  const initialCursor = getCursorsEl()?.dataset.newer || null;
  log('workspace init', { cursor: initialCursor });
  connectEventStream(null);
  scrollToBottom(true);
  updateJumpButton();

  // Highlight any existing code blocks
  if (typeof Prism !== 'undefined') {
    Prism.highlightAllUnder(timeline);
  }

  window.addEventListener('beforeunload', () => {
    if (state.eventSource) {
      log('closing SSE before unload');
      state.eventSource.close();
      state.eventSource = null;
    }
  });
  }

  ready();
})();
</script>
{% endblock %}
