{% extends "base.html" %}
{% load static %}
{% load agent_extras %}

{% block global_header %}{% endblock %}
{% block global_footer %}{% endblock %}

{% block content %}
<main class="min-h-screen bg-slate-50">
  <div class="mx-auto flex min-h-screen w-full flex-col gap-6 px-4 pb-48 pt-8 sm:px-6 lg:px-10">
    <header class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
      <div class="flex flex-col gap-2">
        <a href="{% url 'agents' %}" class="inline-flex items-center gap-2 text-sm font-medium text-slate-500 transition hover:text-indigo-600">
          <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
          Back to agents
        </a>
        <div>
          <h1 class="text-2xl font-semibold text-slate-900">{{ agent.name }}</h1>
          {% if agent.charter %}
            <p class="mt-1 text-sm text-slate-500">{{ agent.charter|truncatechars:160 }}</p>
          {% endif %}
        </div>
      </div>
      <div class="flex items-center gap-2">
        <span class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs font-medium uppercase tracking-wide text-slate-500 shadow-sm">
          <span class="size-2 rounded-full {% if agent.is_active %}bg-emerald-500{% else %}bg-slate-300{% endif %}"></span>
          {% if agent.is_active %}Active{% else %}Paused{% endif %}
        </span>
        {% if agent.schedule %}
          <span class="hidden sm:inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs font-medium uppercase tracking-wide text-slate-500 shadow-sm">
            <svg class="h-3.5 w-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l2.5 2.5M5.25 5.25l1.5 1.5m10.5-1.5l-1.5 1.5M4 12h2m12 0h2M7.5 19.5l1.5-1.5m6 1.5l-1.5-1.5M12 4v2" />
            </svg>
            {{ agent.schedule }}
          </span>
        {% endif %}
      </div>
    </header>

    <div id="agent-workspace-root"
         class="relative flex flex-1 flex-col gap-4"
         data-timeline-limit="{{ timeline_limit }}"
         data-timeline-newer-url="{{ timeline_newer_url }}"
         data-timeline-older-url="{{ timeline_older_url }}"
         data-event-stream-url="{{ event_stream_url }}"
         data-processing-active="{{ processing_active|yesno:'true,false' }}"
         data-agent-first-name="{{ agent_first_name }}">

      <div id="timeline-shell" class="relative flex-1">
        <div id="timeline-events" class="flex h-full flex-col gap-3 overflow-y-auto">
          <div class="flex justify-center py-2 text-xs text-slate-500">
            {% if timeline_window.has_more_older %}
              <button
                class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-medium text-slate-600 shadow-sm transition hover:bg-slate-50"
                hx-get="{{ timeline_older_url }}{% if timeline_window.window_oldest_cursor %}&cursor={{ timeline_window.window_oldest_cursor|urlencode }}{% endif %}&limit={{ timeline_limit }}&current_newest={{ timeline_window.window_newest_cursor|default:''|urlencode }}"
                hx-target="#timeline-events"
                hx-swap="afterbegin">
                Load older
              </button>
            {% endif %}
          </div>
          {% include "console/partials/_agent_timeline_items.html" with events=timeline_window.events agent_first_name=agent_first_name %}
          <div id="processing-indicator-slot" class="mt-2 px-1"></div>
        </div>
      </div>

      <div id="timeline-cursors" class="hidden"
           data-older="{{ timeline_window.window_oldest_cursor|default:'' }}"
           data-newer="{{ timeline_window.window_newest_cursor|default:'' }}"
           data-has-more-older="{{ timeline_window.has_more_older|yesno:'true,false' }}"
           data-has-more-newer="{{ timeline_window.has_more_newer|yesno:'true,false' }}"
           data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>

      <div id="agent-composer-shell" class="composer-shell">
        <div class="composer-surface">
          <form id="agent-web-compose" class="flex flex-col gap-3" hx-post="{% url 'agent_web_message' agent.id %}" hx-swap="none">
            <textarea name="body" rows="3" required
                      class="w-full resize-none rounded-xl border border-slate-200 bg-white/95 px-3 py-2 text-sm shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500/30"
                      placeholder="Send a message..."></textarea>
            <div class="flex flex-wrap items-center justify-between gap-2">
              <p class="text-xs text-slate-500">Markdown supported. Shift + Enter for newline.</p>
              <button type="submit"
                      class="inline-flex items-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Send
              </button>
            </div>
            <input type="hidden" name="current_newest" id="composer-latest-cursor" value="{{ timeline_window.window_newest_cursor|default:'' }}">
          </form>
        </div>
      </div>
    </div>
  </div>
</main>
<button id="jump-to-latest" class="jump-to-latest hidden" type="button" aria-label="Jump to latest" aria-hidden="true" style="display:none;opacity:0">
  <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 5v14m0 0-5-5m5 5 5-5" />
  </svg>
  <span class="sr-only">Jump to latest</span>
</button>
<div id="processing-state" class="hidden" style="display:none" data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>
{% endblock %}

{% block extra_js %}
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<style>
  #agent-workspace-root {
    min-height: 24rem;
  }

  #timeline-shell {
    width: 100%;
    max-width: 82rem;
    margin: 0 auto;
  }

  #timeline-events {
    scroll-behavior: smooth;
    padding: 1rem 0.75rem var(--timeline-bottom-padding, 16rem);
  }

  #timeline-events::-webkit-scrollbar {
    width: 8px;
  }

  #timeline-events::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.4);
    border-radius: 9999px;
  }

  #processing-indicator-slot {
    display: flex;
    justify-content: flex-start;
    pointer-events: none;
  }

  #agent-processing-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.65rem;
    border-radius: 9999px;
    padding: 0.5rem 0.85rem;
    background: rgba(99, 102, 241, 0.12);
    color: #312e81;
    font-size: 0.8rem;
    font-weight: 500;
    box-shadow: 0 4px 14px rgba(99, 102, 241, 0.12);
    border: 1px solid rgba(99, 102, 241, 0.18);
    transition: opacity 0.22s ease, transform 0.22s ease;
  }

  #agent-processing-indicator.processing-indicator--fade {
    opacity: 0;
    transform: translateY(6px);
  }

  .processing-pip {
    width: 0.6rem;
    height: 0.6rem;
    border-radius: 9999px;
    background: #4f46e5;
    box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.4);
    animation: processingPulse 1.6s ease-in-out infinite;
  }

  .processing-label strong {
    font-weight: 600;
  }

  @keyframes processingPulse {
    0% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.48);
    }
    70% {
      transform: scale(1.12);
      box-shadow: 0 0 0 6px rgba(79, 70, 229, 0);
    }
    100% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
    }
  }

  .composer-shell {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 1.5rem;
    display: flex;
    justify-content: center;
    padding: 0 1.25rem;
    z-index: 40;
    pointer-events: none;
  }

  .composer-surface {
    width: 100%;
    max-width: min(60rem, calc(100% - 2.5rem));
    border-radius: 1.2rem;
    background: rgba(255, 255, 255, 0.94);
    backdrop-filter: blur(14px);
    border: 1px solid rgba(226, 232, 240, 0.7);
    box-shadow: 0 18px 42px rgba(15, 23, 42, 0.18);
    padding: 1.5rem;
    pointer-events: auto;
  }

  .jump-to-latest {
    position: fixed;
    left: 50%;
    z-index: 50;
    width: 3.25rem;
    height: 3.25rem;
    bottom: 9rem;
    border-radius: 9999px;
    border: 1px solid rgba(79, 70, 229, 0.2);
    background: #ffffff;
    color: #4f46e5;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 12px 32px rgba(79, 70, 229, 0.18);
    transform: translate(-50%, 0);
    transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.15s ease;
  }

  .jump-to-latest svg {
    width: 1.25rem;
    height: 1.25rem;
  }

  .jump-to-latest:hover {
    transform: translate(-50%, -4px);
    box-shadow: 0 16px 36px rgba(79, 70, 229, 0.24);
  }

  .jump-to-latest:focus-visible {
    outline: 3px solid rgba(59, 130, 246, 0.35);
    outline-offset: 2px;
  }

  .chat-event {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    width: 100%;
  }

  .chat-event.is-user {
    align-items: flex-end;
  }

  .chat-event.is-agent {
    align-items: flex-start;
  }

  .chat-bubble {
    /* allow messages to use more horizontal space on wide screens while remaining readable */
    max-width: min(60rem, 100%);
    border-radius: 1.25rem;
    padding: 1rem 1.25rem;
    font-size: 0.9375rem;
    line-height: 1.5;
    box-shadow: 0 6px 20px rgba(15, 23, 42, 0.12);
  }

  .chat-content {
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  .chat-bubble--user {
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: #fbfbff;
  }

  .chat-bubble--agent {
    background: rgba(248, 249, 255, 0.95);
    color: #1e1b4b;
    border: 1px solid rgba(79, 70, 229, 0.12);
  }

  .chat-author {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    margin-bottom: 0.35rem;
  }

  .chat-author--user {
    color: rgba(255, 255, 255, 0.75);
  }

  .chat-author--agent {
    color: rgba(79, 70, 229, 0.65);
  }

  .chat-meta {
    margin-top: 0.6rem;
    font-size: 0.7rem;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.9);
  }

  .chat-meta.is-user {
    color: rgba(226, 232, 240, 0.9);
    text-align: right;
  }

  .chat-attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.75rem;
  }

  .chat-attachments a {
    display: inline-flex;
    align-items: center;
    gap: 0.45rem;
    border-radius: 9999px;
    padding: 0.35rem 0.75rem;
    font-size: 0.75rem;
    text-decoration: none;
    transition: background 0.18s ease;
  }

  .chat-bubble--agent .chat-attachments a {
    background: rgba(79, 70, 229, 0.08);
    color: #4338ca;
  }

  .chat-bubble--user .chat-attachments a {
    background: rgba(255, 255, 255, 0.2);
    color: #ede9fe;
  }

  .chat-bubble--agent .chat-attachments a:hover {
    background: rgba(79, 70, 229, 0.12);
  }

  .chat-bubble--user .chat-attachments a:hover {
    background: rgba(255, 255, 255, 0.28);
  }

  @media (max-width: 768px) {
    .composer-shell {
      padding: 0 0.85rem;
      bottom: 1rem;
    }

    .composer-surface {
      padding: 1.1rem;
      border-radius: 1rem;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.18);
    }

    #timeline-events {
      padding-bottom: 14rem;
    }

    .jump-to-latest {
      width: 2.85rem;
      height: 2.85rem;
      bottom: 8rem;
      box-shadow: 0 10px 26px rgba(79, 70, 229, 0.2);
    }

    .chat-bubble {
      max-width: 95%;
      font-size: 0.9rem;
    }
  }
</style>

<script>
(function () {
  if (window.__agentWorkspaceInitialized) {
    console.debug('[agent-workspace] script already initialized; skipping');
    return;
  }
  window.__agentWorkspaceInitialized = true;

  const root = document.getElementById('agent-workspace-root');

  if (!root) {
    console.warn('[agent-workspace] root node missing; aborting init.');
    return;
  }

  let attempts = 0;
  const MAX_ATTEMPTS = 20;
  let initialized = false;

  function ready() {
    if (typeof window.htmx === 'undefined') {
      attempts += 1;
      if (attempts === 1) {
        console.warn('[agent-workspace] htmx not yet available; retrying init.');
      }
      if (attempts > MAX_ATTEMPTS) {
        console.error('[agent-workspace] htmx failed to load after retries; realtime disabled.');
        return false;
      }
      window.setTimeout(ready, 150);
      return false;
    }

    init();
    return true;
  }

  function init() {
    if (initialized) {
      return;
    }
    initialized = true;

    const timeline = document.getElementById('timeline-events');
    const processingSlot = document.getElementById('processing-indicator-slot');
    const composer = document.getElementById('agent-web-compose');
    const composerCursor = document.getElementById('composer-latest-cursor');
    const composerSurface = document.querySelector('.composer-surface');
    const getJumpButton = () => document.getElementById('jump-to-latest');
    const agentFirstName = root.dataset.agentFirstName || 'Your agent';
    const getCursorsEl = () => document.getElementById('timeline-cursors');

    const limit = parseInt(root.dataset.timelineLimit || '150', 10);
    const newerUrl = root.dataset.timelineNewerUrl;
    const eventStreamUrl = root.dataset.eventStreamUrl;

    const state = {
      action: 'idle',
      previousScrollHeight: 0,
      lastEventId: null,
      pendingComposerScroll: false,
      autoScroll: true,
      eventSource: null,
      fetchingNewer: false,
      queuedNewerTrigger: null,
      processingActive: false,
    };
    state.processingActive = root.dataset.processingActive === 'true';

    const JUMP_BUTTON_SIZE = 52; // matches 3.25rem
    const JUMP_BUTTON_GAP = 18;
    const BASE_SCROLL_THRESHOLD = 140;

    function getTimelineBottomOffset() {
      if (!timeline) return 0;
      return timeline.scrollHeight - timeline.scrollTop - timeline.clientHeight;
    }

    function updateTimelinePadding() {
      if (!timeline) return;
      const composerHeight = composerSurface?.offsetHeight || 0;
      const padding = Math.max(composerHeight + 80, 220);
      timeline.style.setProperty('--timeline-bottom-padding', `${Math.round(padding)}px`);
    }

    function positionJumpButton() {
      const button = getJumpButton();
      if (!button || !composerSurface) return;
      const rect = composerSurface.getBoundingClientRect();
      const buttonHeight = button.offsetHeight || JUMP_BUTTON_SIZE;
      const desiredTop = rect.top - (buttonHeight + JUMP_BUTTON_GAP);
      const boundedTop = Math.max(desiredTop, 16);
      button.style.top = `${Math.round(boundedTop)}px`;
      button.style.bottom = 'auto';
    }

    function toggleJumpButtonVisibility(visible) {
      const button = getJumpButton();
      if (!button) return;
      if (visible) {
        button.classList.remove('hidden');
        button.setAttribute('aria-hidden', 'false');
        button.style.opacity = '1';
        button.style.display = 'flex';
        window.requestAnimationFrame(positionJumpButton);
      } else {
        button.style.opacity = '0';
        button.classList.add('hidden');
        button.setAttribute('aria-hidden', 'true');
        button.style.display = 'none';
      }
    }

    function isTimelineScrollable() {
      if (!timeline) return false;
      return timeline.scrollHeight - timeline.clientHeight > 1;
    }

    function getScrollThreshold() {
      const composerHeight = composerSurface?.offsetHeight || 0;
      const threshold = Math.max(BASE_SCROLL_THRESHOLD, Math.min(composerHeight + 160, 600));
      return threshold;
    }

    function getPageBottomOffset() {
      const doc = document.documentElement || document.body;
      const body = document.body || { scrollHeight: 0, offsetHeight: 0 };
      const totalHeight = Math.max(
        doc?.scrollHeight || 0,
        doc?.offsetHeight || 0,
        body.scrollHeight || 0,
        body.offsetHeight || 0
      );
      const viewportHeight = window.innerHeight || doc?.clientHeight || 0;
      const scrollY = window.scrollY ?? doc?.scrollTop ?? 0;
      const offset = totalHeight - (scrollY + viewportHeight);
      return offset;
    }

    function isNearBottom() {
      if (!timeline) {
        return true;
      }

      const threshold = getScrollThreshold();

      if (isTimelineScrollable()) {
        const bottomOffset = getTimelineBottomOffset();
        const nearTimeline = bottomOffset <= threshold;
        return nearTimeline;
      }

      const pageOffset = Math.max(getPageBottomOffset(), 0);
      const nearPage = pageOffset <= threshold;
      return nearPage;
    }

    let reconnectDelay = 3000;
    const RECONNECT_MAX = 30000;

    function ensureProcessingSlotPosition() {
      if (!timeline || !processingSlot) return;
      if (processingSlot.parentNode !== timeline) {
        timeline.appendChild(processingSlot);
        return;
      }
      if (timeline.lastElementChild !== processingSlot) {
        timeline.appendChild(processingSlot);
      }
    }

    function scrollToBottom(force) {
      if (!timeline) return;
      const nearBefore = isNearBottom();
      const shouldScroll = force || nearBefore;
      if (!shouldScroll) return;
      timeline.scrollTop = timeline.scrollHeight;
      state.autoScroll = true;
      window.requestAnimationFrame(() => {
        const docHeight = Math.max(document.documentElement?.scrollHeight || 0, document.body?.scrollHeight || 0);
        window.scrollTo({ top: docHeight, behavior: 'smooth' });
        isNearBottom();
      });
    }

    const PROCESSING_NODE_ID = 'agent-processing-indicator';

    function setProcessingDataset(active) {
      const value = active ? 'true' : 'false';
      root.dataset.processingActive = value;
      const cursorNode = getCursorsEl();
      if (cursorNode) {
        cursorNode.dataset.processingActive = value;
      }
    }

    function getProcessingFlag() {
      const cursorNode = getCursorsEl();
      if (cursorNode && typeof cursorNode.dataset.processingActive !== 'undefined') {
        const flag = cursorNode.dataset.processingActive === 'true';
        return flag;
      }
      const fallback = root.dataset.processingActive === 'true';
      return fallback;
    }

    function syncProcessingFromDom() {
      ensureProcessingSlotPosition();
      const desired = getProcessingFlag();
      const node = getProcessingNode();
      if (desired) {
        if (!state.processingActive || !node) {
          showProcessingIndicator();
        }
      } else if (state.processingActive || node) {
        hideProcessingIndicator();
      }
    }

    function getProcessingNode() {
      if (!processingSlot) return null;
      return processingSlot.querySelector(`#${PROCESSING_NODE_ID}`);
    }

    function buildProcessingNode() {
      const pill = document.createElement('div');
      pill.id = PROCESSING_NODE_ID;
      pill.className = 'processing-indicator';
      pill.innerHTML = `
        <span class="processing-pip" aria-hidden="true"></span>
        <span class="processing-label"><strong>${agentFirstName}</strong> is working</span>
      `;
      return pill;
    }

    function showProcessingIndicator() {
      if (!processingSlot) return;
      ensureProcessingSlotPosition();
      let indicator = getProcessingNode();
      if (!indicator) {
        processingSlot.innerHTML = '';
        indicator = buildProcessingNode();
        processingSlot.appendChild(indicator);
      } else {
        indicator.classList.remove('processing-indicator--fade');
      }
      state.processingActive = true;
      setProcessingDataset(true);
      refreshEmptyState();
      if (isNearBottom()) {
        scrollToBottom(true);
      }
    }

    function hideProcessingIndicator() {
      const indicator = getProcessingNode();
      if (!indicator) {
        state.processingActive = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
        return;
      }
      indicator.classList.add('processing-indicator--fade');
      window.setTimeout(() => {
        indicator.remove();
        state.processingActive = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
      }, 220);
    }

    function refreshEmptyState() {
      if (!timeline) return;
      const emptyState = timeline.querySelector('.timeline-empty');
      if (!emptyState) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        emptyState.remove();
      }
    }

    function ensureEmptyState() {
      if (!timeline) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        return;
      }
      if (!timeline.querySelector('.timeline-empty')) {
        const emptyState = document.createElement('div');
        emptyState.className = 'timeline-empty text-center text-sm text-slate-400';
        emptyState.textContent = 'No activity yet.';
        timeline.appendChild(emptyState);
      }
    }

    function updateComposerCursor() {
      const cursorNode = getCursorsEl();
      if (composerCursor && cursorNode) {
        composerCursor.value = cursorNode.dataset.newer || '';
      }
    }

    function updateJumpButton() {
      const button = getJumpButton();
      if (!button) return;
      positionJumpButton();
      const show = !isNearBottom();
      toggleJumpButtonVisibility(show);
    }

    function trimTimeline(direction) {
      if (!timeline) return;
      const nodes = Array.from(timeline.querySelectorAll('.timeline-event[data-cursor]'));
      if (nodes.length <= limit) return;
      const excess = nodes.length - limit;
      if (direction === 'older') {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[nodes.length - 1 - i];
          if (node) node.remove();
        }
      } else {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[i];
          if (node) node.remove();
        }
      }
      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function dedupeTimeline() {
      if (!timeline) return;
      const seen = new Set();
      const items = timeline.querySelectorAll('.timeline-event[data-cursor]');
      for (let i = items.length - 1; i >= 0; i -= 1) {
        const node = items[i];
        const cursor = node?.dataset?.cursor;
        if (!cursor) continue;
        if (seen.has(cursor)) {
          node.remove();
        } else {
          seen.add(cursor);
        }
      }
      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function completeNewerRequest() {
      state.fetchingNewer = false;
      const queuedTrigger = state.queuedNewerTrigger;
      state.queuedNewerTrigger = null;
      if (queuedTrigger) {
        requestNewer(queuedTrigger);
      }
    }

    function requestNewer(trigger) {
      if (!newerUrl || !timeline) return;
      if (state.fetchingNewer) {
        state.queuedNewerTrigger = trigger || 'auto-newer';
        return;
      }
      const params = new URLSearchParams({ limit: String(limit) });
      const cursorNode = getCursorsEl();
      const cursor = cursorNode?.dataset.newer;
      if (cursor) params.set('cursor', cursor);

      state.action = 'newer';
      state.fetchingNewer = true;
      const nearBottom = isNearBottom();
      state.autoScroll = state.pendingComposerScroll ? true : nearBottom;

      window.htmx.ajax('GET', `${newerUrl}&${params.toString()}`, {
        target: '#timeline-events',
        swap: 'beforeend',
      });
    }

    if (timeline) {
      timeline.addEventListener('scroll', () => {
        const nearBottom = isNearBottom();
        state.autoScroll = nearBottom;
        updateJumpButton();
      });
    }

    const handleWindowScroll = () => {
      const nearBottom = isNearBottom();
      state.autoScroll = nearBottom;
      updateJumpButton();
    };

    window.addEventListener('scroll', handleWindowScroll, { passive: true });

    const handleResize = () => {
      updateTimelinePadding();
      positionJumpButton();
      updateJumpButton();
    };

    const handleOrientationChange = () => {
      updateTimelinePadding();
      positionJumpButton();
      updateJumpButton();
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleOrientationChange);

    document.addEventListener('click', (event) => {
      const btn = event.target.closest('#jump-to-latest');
      if (!btn) return;
      scrollToBottom(true);
      state.autoScroll = true;
      toggleJumpButtonVisibility(false);
    });

    if (composer) {
      composer.addEventListener('htmx:beforeRequest', () => {
        state.pendingComposerScroll = true;
      });
      composer.addEventListener('htmx:afterRequest', (event) => {
        if (event.detail && event.detail.xhr && event.detail.xhr.status < 400) {
          composer.reset();
          showProcessingIndicator();
        } else {
          state.pendingComposerScroll = false;
        }
      });

      const composerTextarea = composer.querySelector('textarea');
      if (composerTextarea) {
        const scheduleLayoutUpdate = () => window.requestAnimationFrame(() => {
          updateTimelinePadding();
          positionJumpButton();
          updateJumpButton();
        });
        composerTextarea.addEventListener('input', scheduleLayoutUpdate);
        composerTextarea.addEventListener('focus', scheduleLayoutUpdate);
        composerTextarea.addEventListener('blur', scheduleLayoutUpdate);
      }
    }

    window.htmx.on('htmx:beforeRequest', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      const url = event.detail.requestConfig?.path || '';
      if (url.includes('direction=older')) {
        state.action = 'older';
        state.previousScrollHeight = timeline?.scrollHeight || 0;
      } else if (url.includes('direction=newer')) {
        state.action = 'newer';
      }
    });

    window.htmx.on('htmx:afterSwap', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;


      ensureProcessingSlotPosition();
      updateTimelinePadding();

      if (state.action === 'older' && timeline) {
        const delta = timeline.scrollHeight - state.previousScrollHeight;
        timeline.scrollTop = Math.max(delta, 0);
      }

      dedupeTimeline();
      trimTimeline(state.action);
      updateComposerCursor();

      if (typeof Prism !== 'undefined') {
        Prism.highlightAllUnder(timeline);
      }

      if (state.autoScroll) {
        scrollToBottom(true);
      }

      if (state.action === 'newer' || state.fetchingNewer) {
        completeNewerRequest();
      }

      state.action = 'idle';
      state.previousScrollHeight = 0;
      state.pendingComposerScroll = false;
      state.autoScroll = isNearBottom();
      updateJumpButton();
      refreshEmptyState();
      syncProcessingFromDom();
    });

    window.htmx.on('htmx:afterSettle', (event) => {
      if (event.detail?.target?.id === 'timeline-events') {
        ensureProcessingSlotPosition();
        updateTimelinePadding();
        updateJumpButton();
        refreshEmptyState();
        syncProcessingFromDom();
      }
    });

    window.htmx.on('htmx:responseError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      completeNewerRequest();
    });

    window.htmx.on('htmx:sendError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      completeNewerRequest();
    });

    const handleProcessingStartedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      showProcessingIndicator();
    };

    const handleProcessingFinishedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      hideProcessingIndicator();
      requestNewer('processing-finished');
    };

    function connectEventStream(lastId) {
      if (!eventStreamUrl) {
        console.warn('[agent-workspace] Missing eventStreamUrl dataset attribute; realtime updates disabled.');
        return;
      }

      if (typeof window.EventSource === 'undefined') {
        console.warn('[agent-workspace] EventSource API unavailable; realtime updates disabled.');
        return;
      }

      let cursor = lastId;
      if (cursor && !/^[0-9]+-[0-9]+$/.test(cursor)) {
        cursor = null;
      }

      const url = cursor ? `${eventStreamUrl}?cursor=${encodeURIComponent(cursor)}` : eventStreamUrl;
      const source = new EventSource(url);

      source.onopen = () => {
      };

      const handleMessage = (evt) => {
        if (evt.lastEventId) {
          state.lastEventId = evt.lastEventId;
        }
        reconnectDelay = 3000;
        requestNewer('auto-newer');
      };

      source.addEventListener('message', handleMessage);
      source.addEventListener('step.created', handleMessage);
      source.addEventListener('message.created', handleMessage);
      source.addEventListener('processing.started', handleProcessingStartedEvent);
      source.addEventListener('processing.finished', handleProcessingFinishedEvent);
      source.onerror = (err) => {
        source.close();
        state.eventSource = null;
        reconnectDelay = Math.min(Math.round(reconnectDelay * 1.5), RECONNECT_MAX);
        window.setTimeout(() => connectEventStream(state.lastEventId), reconnectDelay);
        hideProcessingIndicator();
      };

      state.eventSource = source;
    }

    const initialCursor = getCursorsEl()?.dataset.newer || null;
    ensureProcessingSlotPosition();
    syncProcessingFromDom();
    connectEventStream(null);
    updateTimelinePadding();
    positionJumpButton();
    scrollToBottom(true);
    updateJumpButton();
    refreshEmptyState();

    if (typeof Prism !== 'undefined') {
      Prism.highlightAllUnder(timeline);
    }

    window.addEventListener('beforeunload', () => {
      window.removeEventListener('scroll', handleWindowScroll);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleOrientationChange);
      if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
      }
    });
  }

  ready();
})();
</script>
{% endblock %}
