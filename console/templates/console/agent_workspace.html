{% extends "base.html" %}
{% load static %}
{% load agent_extras %}

{% block global_header %}{% endblock %}
{% block global_footer %}{% endblock %}

{% block content %}
<main class="min-h-screen bg-slate-50">
  <div class="mx-auto flex min-h-screen w-full flex-col gap-6 px-4 pb-48 pt-8 sm:px-6 lg:px-10">
    <header class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
      <div class="flex flex-col gap-2">
        <a href="{% url 'agents' %}" class="inline-flex items-center gap-2 text-sm font-medium text-slate-500 transition hover:text-indigo-600">
          <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
          Back to agents
        </a>
        <div>
          <h1 class="text-2xl font-semibold text-slate-900">{{ agent.name }}</h1>
          {% if agent.charter %}
            <p class="mt-1 text-sm text-slate-500">{{ agent.charter|truncatechars:160 }}</p>
          {% endif %}
        </div>
      </div>
      <div class="flex items-center gap-2">
        <span class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs font-medium uppercase tracking-wide text-slate-500 shadow-sm">
          <span class="size-2 rounded-full {% if agent.is_active %}bg-emerald-500{% else %}bg-slate-300{% endif %}"></span>
          {% if agent.is_active %}Active{% else %}Paused{% endif %}
        </span>
        {% if agent.schedule %}
          <span class="hidden sm:inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs font-medium uppercase tracking-wide text-slate-500 shadow-sm">
            <svg class="h-3.5 w-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l2.5 2.5M5.25 5.25l1.5 1.5m10.5-1.5l-1.5 1.5M4 12h2m12 0h2M7.5 19.5l1.5-1.5m6 1.5l-1.5-1.5M12 4v2" />
            </svg>
            {{ agent.schedule }}
          </span>
        {% endif %}
      </div>
    </header>

    <div id="agent-workspace-root"
         class="relative flex flex-1 flex-col gap-4"
         data-timeline-limit="{{ timeline_limit }}"
         data-timeline-newer-url="{{ timeline_newer_url }}"
         data-timeline-older-url="{{ timeline_older_url }}"
         data-event-stream-url="{{ event_stream_url }}"
         data-processing-active="{{ processing_active|yesno:'true,false' }}"
         data-agent-first-name="{{ agent_first_name }}">

      <div id="timeline-shell" class="relative flex-1">
        <div id="timeline-events" class="flex h-full flex-col gap-3 overflow-y-auto">
          <div class="flex justify-center py-2 text-xs text-slate-500">
            {% if timeline_window.has_more_older %}
              <button
                class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-medium text-slate-600 shadow-sm transition hover:bg-slate-50"
                hx-get="{{ timeline_older_url }}{% if timeline_window.window_oldest_cursor %}&cursor={{ timeline_window.window_oldest_cursor|urlencode }}{% endif %}&limit={{ timeline_limit }}&current_newest={{ timeline_window.window_newest_cursor|default:''|urlencode }}"
                hx-target="#timeline-events"
                hx-swap="afterbegin">
                Load older
              </button>
            {% endif %}
          </div>
          {% include "console/partials/_agent_timeline_items.html" with events=timeline_window.events agent_first_name=agent_first_name %}
          <div id="processing-indicator-slot" class="mt-2 px-1"></div>
        </div>
      </div>

      <div id="timeline-cursors" class="hidden"
           data-older="{{ timeline_window.window_oldest_cursor|default:'' }}"
           data-newer="{{ timeline_window.window_newest_cursor|default:'' }}"
           data-has-more-older="{{ timeline_window.has_more_older|yesno:'true,false' }}"
           data-has-more-newer="{{ timeline_window.has_more_newer|yesno:'true,false' }}"
           data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>

      <div id="agent-composer-shell" class="composer-shell">
        <div class="composer-surface">
          <form id="agent-web-compose" class="flex flex-col gap-3" hx-post="{% url 'agent_web_message' agent.id %}" hx-swap="none">
            <textarea name="body" rows="3" required
                      class="w-full resize-none rounded-xl border border-slate-200 bg-white/95 px-3 py-2 text-sm shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500/30"
                      placeholder="Send a message..."></textarea>
            <div class="flex flex-wrap items-center justify-between gap-2">
              <p class="text-xs text-slate-500">Markdown supported. Shift + Enter for newline.</p>
              <button type="submit"
                      class="inline-flex items-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Send
              </button>
            </div>
            <input type="hidden" name="current_newest" id="composer-latest-cursor" value="{{ timeline_window.window_newest_cursor|default:'' }}">
          </form>
        </div>
      </div>
    </div>
  </div>
</main>
<button id="jump-to-latest" class="jump-to-latest hidden" type="button">Jump to latest</button>
<div id="processing-state" class="hidden" style="display:none" data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>
{% endblock %}

{% block extra_js %}
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<style>
  #agent-workspace-root {
    min-height: 24rem;
  }

  #timeline-events {
    scroll-behavior: smooth;
    padding: 1rem 0.75rem 16rem;
  }

  #timeline-events::-webkit-scrollbar {
    width: 8px;
  }

  #timeline-events::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.4);
    border-radius: 9999px;
  }

  #processing-indicator-slot {
    display: flex;
    justify-content: flex-start;
    pointer-events: none;
  }

  #agent-processing-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.65rem;
    border-radius: 9999px;
    padding: 0.5rem 0.85rem;
    background: rgba(99, 102, 241, 0.12);
    color: #312e81;
    font-size: 0.8rem;
    font-weight: 500;
    box-shadow: 0 4px 14px rgba(99, 102, 241, 0.12);
    border: 1px solid rgba(99, 102, 241, 0.18);
    transition: opacity 0.22s ease, transform 0.22s ease;
  }

  #agent-processing-indicator.processing-indicator--fade {
    opacity: 0;
    transform: translateY(6px);
  }

  .processing-pip {
    width: 0.6rem;
    height: 0.6rem;
    border-radius: 9999px;
    background: #4f46e5;
    box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.4);
    animation: processingPulse 1.6s ease-in-out infinite;
  }

  .processing-label strong {
    font-weight: 600;
  }

  @keyframes processingPulse {
    0% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.48);
    }
    70% {
      transform: scale(1.12);
      box-shadow: 0 0 0 6px rgba(79, 70, 229, 0);
    }
    100% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
    }
  }

  .composer-shell {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 1.5rem;
    display: flex;
    justify-content: center;
    padding: 0 1.25rem;
    z-index: 40;
    pointer-events: none;
  }

  .composer-surface {
    width: 100%;
    max-width: 100%;
    border-radius: 1.2rem;
    background: rgba(255, 255, 255, 0.94);
    backdrop-filter: blur(14px);
    border: 1px solid rgba(226, 232, 240, 0.7);
    box-shadow: 0 18px 42px rgba(15, 23, 42, 0.18);
    padding: 1.5rem;
    pointer-events: auto;
  }

  .jump-to-latest {
    position: fixed;
    right: 1.75rem;
    bottom: 9rem;
    z-index: 30;
    border-radius: 9999px;
    border: 1px solid rgba(79, 70, 229, 0.25);
    background: white;
    color: #4f46e5;
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.5rem 0.95rem;
    box-shadow: 0 10px 28px rgba(79, 70, 229, 0.16);
    transition: transform 0.18s ease, box-shadow 0.18s ease;
  }

  .jump-to-latest:hover {
    transform: translateY(-2px);
    box-shadow: 0 14px 30px rgba(79, 70, 229, 0.22);
  }

  .chat-event {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .chat-event.is-user {
    align-items: flex-end;
  }

  .chat-event.is-agent {
    align-items: flex-start;
  }

  .chat-bubble {
    max-width: min(36rem, 100%);
    border-radius: 1.25rem;
    padding: 0.85rem 1.1rem;
    font-size: 0.9375rem;
    line-height: 1.5;
    box-shadow: 0 6px 20px rgba(15, 23, 42, 0.12);
  }

  .chat-bubble--user {
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: #fbfbff;
  }

  .chat-bubble--agent {
    background: rgba(248, 249, 255, 0.95);
    color: #1e1b4b;
    border: 1px solid rgba(79, 70, 229, 0.12);
  }

  .chat-author {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    margin-bottom: 0.35rem;
  }

  .chat-author--user {
    color: rgba(255, 255, 255, 0.75);
  }

  .chat-author--agent {
    color: rgba(79, 70, 229, 0.65);
  }

  .chat-meta {
    margin-top: 0.6rem;
    font-size: 0.7rem;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.9);
  }

  .chat-meta.is-user {
    color: rgba(226, 232, 240, 0.9);
    text-align: right;
  }

  .chat-attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.75rem;
  }

  .chat-attachments a {
    display: inline-flex;
    align-items: center;
    gap: 0.45rem;
    border-radius: 9999px;
    padding: 0.35rem 0.75rem;
    font-size: 0.75rem;
    text-decoration: none;
    transition: background 0.18s ease;
  }

  .chat-bubble--agent .chat-attachments a {
    background: rgba(79, 70, 229, 0.08);
    color: #4338ca;
  }

  .chat-bubble--user .chat-attachments a {
    background: rgba(255, 255, 255, 0.2);
    color: #ede9fe;
  }

  .chat-bubble--agent .chat-attachments a:hover {
    background: rgba(79, 70, 229, 0.12);
  }

  .chat-bubble--user .chat-attachments a:hover {
    background: rgba(255, 255, 255, 0.28);
  }

  .chat-details summary {
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    font-weight: 500;
  }

  .chat-details.is-user {
    color: rgba(237, 233, 254, 0.9);
  }

  .chat-details.is-agent {
    color: rgba(99, 102, 241, 0.85);
  }

  .chat-details-panel {
    margin-top: 0.5rem;
    border-radius: 0.9rem;
    border: 1px solid rgba(148, 163, 184, 0.12);
    background: rgba(248, 250, 252, 0.7);
    padding: 0.75rem;
    font-size: 0.72rem;
    line-height: 1.4;
    color: rgba(71, 85, 105, 0.9);
  }

  .chat-details.is-user .chat-details-panel {
    background: rgba(79, 70, 229, 0.18);
    color: rgba(237, 233, 254, 0.95);
    border-color: rgba(214, 214, 255, 0.26);
  }

  @media (max-width: 768px) {
    .composer-shell {
      padding: 0 0.85rem;
      bottom: 1rem;
    }

    .composer-surface {
      padding: 1.1rem;
      border-radius: 1rem;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.18);
    }

    #timeline-events {
      padding-bottom: 14rem;
    }

    .jump-to-latest {
      right: 1rem;
      bottom: 8rem;
    }

    .chat-bubble {
      max-width: 95%;
      font-size: 0.9rem;
    }
  }
</style>

<script>
(function () {
  if (window.__agentWorkspaceInitialized) {
    console.debug('[agent-workspace] script already initialized; skipping');
    return;
  }
  window.__agentWorkspaceInitialized = true;

  const root = document.getElementById('agent-workspace-root');
  const log = (...args) => console.debug('[agent-workspace]', ...args);

  if (!root) {
    console.warn('[agent-workspace] root node missing; aborting init.');
    return;
  }

  let attempts = 0;
  const MAX_ATTEMPTS = 20;
  let initialized = false;

  function ready() {
    if (typeof window.htmx === 'undefined') {
      attempts += 1;
      log('htmx wait attempt', { attempts });
      if (attempts === 1) {
        console.warn('[agent-workspace] htmx not yet available; retrying init.');
      }
      if (attempts > MAX_ATTEMPTS) {
        console.error('[agent-workspace] htmx failed to load after retries; realtime disabled.');
        return false;
      }
      window.setTimeout(ready, 150);
      return false;
    }

    log('initializing workspace timeline', { dataset: { newerUrl: root.dataset.timelineNewerUrl, olderUrl: root.dataset.timelineOlderUrl, eventStreamUrl: root.dataset.eventStreamUrl } });
    init();
    return true;
  }

  function init() {
    if (initialized) {
      log('init called after initialization; skipping');
      return;
    }
    initialized = true;

    const timeline = document.getElementById('timeline-events');
    const processingSlot = document.getElementById('processing-indicator-slot');
    const composer = document.getElementById('agent-web-compose');
    const composerCursor = document.getElementById('composer-latest-cursor');
    const jumpButton = document.getElementById('jump-to-latest');
    const agentFirstName = root.dataset.agentFirstName || 'Your agent';
    const getCursorsEl = () => document.getElementById('timeline-cursors');

    const limit = parseInt(root.dataset.timelineLimit || '150', 10);
    const newerUrl = root.dataset.timelineNewerUrl;
    const eventStreamUrl = root.dataset.eventStreamUrl;

    const state = {
      action: 'idle',
      previousScrollHeight: 0,
      lastEventId: null,
      pendingComposerScroll: false,
      autoScroll: true,
      eventSource: null,
      fetchingNewer: false,
      queuedNewerTrigger: null,
      processingActive: false,
    };
    state.processingActive = root.dataset.processingActive === 'true';
    log('processing.initial-state', { fromRoot: state.processingActive, dataset: root.dataset.processingActive });

    let reconnectDelay = 3000;
    const RECONNECT_MAX = 30000;

    function ensureProcessingSlotPosition() {
      if (!timeline || !processingSlot) return;
      if (processingSlot.parentNode !== timeline) {
        timeline.appendChild(processingSlot);
        return;
      }
      if (timeline.lastElementChild !== processingSlot) {
        timeline.appendChild(processingSlot);
      }
    }

    function isNearBottom() {
      if (!timeline) return true;
      const threshold = 140;
      return timeline.scrollHeight - timeline.scrollTop - timeline.clientHeight <= threshold;
    }

    function scrollToBottom(force) {
      if (!timeline) return;
      if (force || isNearBottom()) {
        timeline.scrollTop = timeline.scrollHeight;
      }
    }

    const PROCESSING_NODE_ID = 'agent-processing-indicator';

    function setProcessingDataset(active) {
      const value = active ? 'true' : 'false';
      root.dataset.processingActive = value;
      const cursorNode = getCursorsEl();
      if (cursorNode) {
        cursorNode.dataset.processingActive = value;
      }
      log('processing.dataset.update', { active: value, rootDataset: root.dataset.processingActive, cursorDataset: cursorNode?.dataset?.processingActive });
    }

    function getProcessingFlag() {
      const cursorNode = getCursorsEl();
      if (cursorNode && typeof cursorNode.dataset.processingActive !== 'undefined') {
        const flag = cursorNode.dataset.processingActive === 'true';
        log('processing.flag.cursor', { flag, dataset: cursorNode.dataset.processingActive });
        return flag;
      }
      const fallback = root.dataset.processingActive === 'true';
      log('processing.flag.root', { fallback, dataset: root.dataset.processingActive });
      return fallback;
    }

    function syncProcessingFromDom() {
      ensureProcessingSlotPosition();
      const desired = getProcessingFlag();
      log('processing.sync', { desired, currentState: state.processingActive, hasNode: !!getProcessingNode() });
      const node = getProcessingNode();
      if (desired) {
        if (!state.processingActive || !node) {
          showProcessingIndicator();
        }
      } else if (state.processingActive || node) {
        hideProcessingIndicator();
      }
    }

    function getProcessingNode() {
      if (!processingSlot) return null;
      return processingSlot.querySelector(`#${PROCESSING_NODE_ID}`);
    }

    function buildProcessingNode() {
      const pill = document.createElement('div');
      pill.id = PROCESSING_NODE_ID;
      pill.className = 'processing-indicator';
      pill.innerHTML = `
        <span class="processing-pip" aria-hidden="true"></span>
        <span class="processing-label"><strong>${agentFirstName}</strong> is working</span>
      `;
      return pill;
    }

    function showProcessingIndicator() {
      if (!processingSlot) return;
      ensureProcessingSlotPosition();
      let indicator = getProcessingNode();
      if (!indicator) {
        processingSlot.innerHTML = '';
        indicator = buildProcessingNode();
        processingSlot.appendChild(indicator);
      } else {
        indicator.classList.remove('processing-indicator--fade');
      }
      state.processingActive = true;
      setProcessingDataset(true);
      refreshEmptyState();
      if (isNearBottom()) {
        scrollToBottom(true);
      }
      log('processing.show');
    }

    function hideProcessingIndicator() {
      const indicator = getProcessingNode();
      if (!indicator) {
        state.processingActive = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
        log('processing.hide.no-indicator');
        return;
      }
      indicator.classList.add('processing-indicator--fade');
      window.setTimeout(() => {
        indicator.remove();
        state.processingActive = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
      }, 220);
      log('processing.hide.transition');
    }

    function refreshEmptyState() {
      if (!timeline) return;
      const emptyState = timeline.querySelector('.timeline-empty');
      if (!emptyState) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        emptyState.remove();
      }
    }

    function ensureEmptyState() {
      if (!timeline) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        return;
      }
      if (!timeline.querySelector('.timeline-empty')) {
        const emptyState = document.createElement('div');
        emptyState.className = 'timeline-empty text-center text-sm text-slate-400';
        emptyState.textContent = 'No activity yet.';
        timeline.appendChild(emptyState);
      }
    }

    function updateComposerCursor() {
      const cursorNode = getCursorsEl();
      if (composerCursor && cursorNode) {
        composerCursor.value = cursorNode.dataset.newer || '';
      }
    }

    function updateJumpButton() {
      if (!jumpButton) return;
      const cursorNode = getCursorsEl();
      const hasMoreNewer = cursorNode?.dataset.hasMoreNewer === 'true';
      if (!hasMoreNewer || isNearBottom()) {
        jumpButton.classList.add('hidden');
        return;
      }
      jumpButton.classList.remove('hidden');
    }

    function trimTimeline(direction) {
      if (!timeline) return;
      const nodes = Array.from(timeline.querySelectorAll('.timeline-event[data-cursor]'));
      if (nodes.length <= limit) return;
      const excess = nodes.length - limit;
      log('trimming timeline', { direction, excess });
      if (direction === 'older') {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[nodes.length - 1 - i];
          if (node) node.remove();
        }
      } else {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[i];
          if (node) node.remove();
        }
      }
      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function dedupeTimeline() {
      if (!timeline) return;
      const seen = new Set();
      const items = timeline.querySelectorAll('.timeline-event[data-cursor]');
      for (let i = items.length - 1; i >= 0; i -= 1) {
        const node = items[i];
        const cursor = node?.dataset?.cursor;
        if (!cursor) continue;
        if (seen.has(cursor)) {
          node.remove();
        } else {
          seen.add(cursor);
        }
      }
      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function completeNewerRequest() {
      state.fetchingNewer = false;
      const queuedTrigger = state.queuedNewerTrigger;
      state.queuedNewerTrigger = null;
      if (queuedTrigger) {
        log('consuming queued newer request', { trigger: queuedTrigger });
        requestNewer(queuedTrigger);
      }
    }

    function requestNewer(trigger) {
      if (!newerUrl || !timeline) return;
      if (state.fetchingNewer) {
        state.queuedNewerTrigger = trigger || 'auto-newer';
        log('requestNewer queued', { trigger });
        return;
      }
      const params = new URLSearchParams({ limit: String(limit) });
      const cursorNode = getCursorsEl();
      const cursor = cursorNode?.dataset.newer;
      if (cursor) params.set('cursor', cursor);

      state.action = 'newer';
      state.fetchingNewer = true;
      state.autoScroll = state.pendingComposerScroll ? true : trigger !== 'auto-newer' ? true : isNearBottom();

      log('requestNewer', { trigger, cursor, autoScroll: state.autoScroll });

      window.htmx.ajax('GET', `${newerUrl}&${params.toString()}`, {
        target: '#timeline-events',
        swap: 'beforeend',
      });
    }

    if (timeline) {
      timeline.addEventListener('scroll', () => {
        state.autoScroll = isNearBottom();
        log('scroll', { autoScroll: state.autoScroll });
        updateJumpButton();
      });
    }

    document.addEventListener('click', (event) => {
      const btn = event.target.closest('#jump-to-latest');
      if (!btn) return;
      log('jump-to-latest clicked');
      scrollToBottom(true);
      state.autoScroll = true;
      btn.classList.add('hidden');
    });

    if (composer) {
      composer.addEventListener('htmx:beforeRequest', () => {
        state.pendingComposerScroll = true;
        log('composer submit start');
      });
      composer.addEventListener('htmx:afterRequest', (event) => {
        if (event.detail && event.detail.xhr && event.detail.xhr.status < 400) {
          composer.reset();
          log('composer submit success');
          showProcessingIndicator();
        } else {
          state.pendingComposerScroll = false;
          log('composer submit error', event.detail?.xhr?.status);
        }
      });
    }

    window.htmx.on('htmx:beforeRequest', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      const url = event.detail.requestConfig?.path || '';
      log('htmx beforeRequest', { url });
      if (url.includes('direction=older')) {
        state.action = 'older';
        state.previousScrollHeight = timeline?.scrollHeight || 0;
      } else if (url.includes('direction=newer')) {
        state.action = 'newer';
      }
    });

    window.htmx.on('htmx:afterSwap', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;

      log('htmx afterSwap', { action: state.action, autoScroll: state.autoScroll });

      ensureProcessingSlotPosition();

      if (state.action === 'older' && timeline) {
        const delta = timeline.scrollHeight - state.previousScrollHeight;
        timeline.scrollTop = Math.max(delta, 0);
      }

      dedupeTimeline();
      trimTimeline(state.action);
      updateComposerCursor();

      if (typeof Prism !== 'undefined') {
        Prism.highlightAllUnder(timeline);
      }

      if (state.autoScroll) {
        log('auto-scroll applied');
        scrollToBottom(true);
      }

      if (state.action === 'newer' || state.fetchingNewer) {
        completeNewerRequest();
      }

      state.action = 'idle';
      state.previousScrollHeight = 0;
      state.pendingComposerScroll = false;
      state.autoScroll = isNearBottom();
      updateJumpButton();
      refreshEmptyState();
      syncProcessingFromDom();
    });

    window.htmx.on('htmx:afterSettle', (event) => {
      if (event.detail?.target?.id === 'timeline-events') {
        log('htmx afterSettle');
        ensureProcessingSlotPosition();
        updateJumpButton();
        refreshEmptyState();
        syncProcessingFromDom();
      }
    });

    window.htmx.on('htmx:responseError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      log('htmx responseError', { status: event.detail.xhr?.status });
      completeNewerRequest();
    });

    window.htmx.on('htmx:sendError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      log('htmx sendError');
      completeNewerRequest();
    });

    const handleProcessingStartedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      log('SSE processing.started', { lastId: evt?.lastEventId });
      showProcessingIndicator();
    };

    const handleProcessingFinishedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      log('SSE processing.finished', { lastId: evt?.lastEventId });
      hideProcessingIndicator();
      requestNewer('processing-finished');
    };

    function connectEventStream(lastId) {
      if (!eventStreamUrl) {
        console.warn('[agent-workspace] Missing eventStreamUrl dataset attribute; realtime updates disabled.');
        return;
      }

      if (typeof window.EventSource === 'undefined') {
        console.warn('[agent-workspace] EventSource API unavailable; realtime updates disabled.');
        return;
      }

      let cursor = lastId;
      if (cursor && !/^[0-9]+-[0-9]+$/.test(cursor)) {
        log('invalid_last_event_id_format', { cursor });
        cursor = null;
      }

      const url = cursor ? `${eventStreamUrl}?cursor=${encodeURIComponent(cursor)}` : eventStreamUrl;
      log('connecting SSE', { url, cursor });
      const source = new EventSource(url);

      source.onopen = () => {
        log('SSE open');
      };

      const handleMessage = (evt) => {
        if (evt.lastEventId) {
          state.lastEventId = evt.lastEventId;
        }
        reconnectDelay = 3000;
        log('SSE message', { event: evt.type || 'message', lastId: evt.lastEventId });
        requestNewer('auto-newer');
      };

      source.addEventListener('message', handleMessage);
      source.addEventListener('step.created', handleMessage);
      source.addEventListener('message.created', handleMessage);
      source.addEventListener('processing.started', handleProcessingStartedEvent);
      source.addEventListener('processing.finished', handleProcessingFinishedEvent);
      source.onerror = (err) => {
        log('SSE error', err);
        source.close();
        state.eventSource = null;
        reconnectDelay = Math.min(Math.round(reconnectDelay * 1.5), RECONNECT_MAX);
        log('SSE reconnect scheduled', reconnectDelay);
        window.setTimeout(() => connectEventStream(state.lastEventId), reconnectDelay);
        hideProcessingIndicator();
      };

      state.eventSource = source;
    }

    const initialCursor = getCursorsEl()?.dataset.newer || null;
    log('workspace init', { cursor: initialCursor });
    ensureProcessingSlotPosition();
    syncProcessingFromDom();
    connectEventStream(null);
    scrollToBottom(true);
    updateJumpButton();
    refreshEmptyState();

    if (typeof Prism !== 'undefined') {
      Prism.highlightAllUnder(timeline);
    }

    window.addEventListener('beforeunload', () => {
      if (state.eventSource) {
        log('closing SSE before unload');
        state.eventSource.close();
        state.eventSource = null;
      }
    });
  }

  ready();
})();
</script>
{% endblock %}
