{% extends "console_page.html" %}
{% load static %}
{% load agent_extras %}

{% block console_content %}
<div class="space-y-6">
  <header class="bg-white/80 backdrop-blur-sm shadow-xl rounded-xl overflow-hidden">
    <div class="px-6 py-4">
      <h1 class="text-xl font-semibold text-gray-800">Conversation with {{ agent.name }}</h1>
    </div>
  </header>

  <div id="agent-workspace-root"
       class="flex h-full flex-col gap-6"
       data-timeline-limit="{{ timeline_limit }}"
       data-timeline-newer-url="{{ timeline_newer_url }}"
       data-timeline-older-url="{{ timeline_older_url }}"
       data-event-stream-url="{{ event_stream_url }}"
       data-processing-active="{{ processing_active|yesno:'true,false' }}">

    <div id="timeline-events" class="flex h-full flex-col gap-3 overflow-y-auto">
      <div class="flex justify-center py-2 text-xs text-slate-500">
        {% if timeline_window.has_more_older %}
          <button
            class="inline-flex items-center gap-2 rounded-full border border-gray-200 bg-white px-3 py-1.5 text-xs font-medium text-gray-600 shadow-sm hover:bg-gray-50"
            hx-get="{{ timeline_older_url }}{% if timeline_window.window_oldest_cursor %}&cursor={{ timeline_window.window_oldest_cursor|urlencode }}{% endif %}&limit={{ timeline_limit }}&current_newest={{ timeline_window.window_newest_cursor|default:''|urlencode }}"
            hx-target="#timeline-events"
            hx-swap="afterbegin">
            Load older
          </button>
        {% endif %}
      </div>
      {% include "console/partials/_agent_timeline_items.html" with events=timeline_window.events %}
    </div>

    <div id="timeline-cursors" class="hidden"
         data-older="{{ timeline_window.window_oldest_cursor|default:'' }}"
         data-newer="{{ timeline_window.window_newest_cursor|default:'' }}"
         data-has-more-older="{{ timeline_window.has_more_older|yesno:'true,false' }}"
         data-has-more-newer="{{ timeline_window.has_more_newer|yesno:'true,false' }}"
         data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>

    <button id="jump-to-latest"
            class="hidden absolute bottom-20 left-1/2 z-20 -translate-x-1/2 rounded-full border border-gray-200 bg-white px-3 py-1 text-xs font-semibold text-indigo-600 shadow-lg"
            type="button">
      Jump to latest
    </button>

    <div class="bg-white/80 backdrop-blur-sm shadow-xl rounded-xl overflow-hidden p-4">
      <form id="agent-web-compose" class="flex flex-col gap-3" hx-post="{% url 'agent_web_message' agent.id %}" hx-swap="none">
      <textarea name="body" rows="3" required
                class="w-full resize-none rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                placeholder="Send a message..."></textarea>
      <div class="flex items-center justify-between">
        <p class="text-xs text-gray-500">Markdown supported. Shift + Enter for newline.</p>
        <button type="submit"
                class="inline-flex items-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
          Send
        </button>
      </div>
        <input type="hidden" name="current_newest" id="composer-latest-cursor" value="{{ timeline_window.window_newest_cursor|default:'' }}">
      </form>
    </div>
  </div>
</div>
<div id="processing-state" class="hidden" style="display:none" data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>
{% endblock %}

{% block extra_js %}
<!-- Prism.js for SQL syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<style>
  @keyframes processingShimmer {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
  }

  @keyframes processingPulse {
    0%, 100% { transform: scale(1); opacity: 0.65; }
    50% { transform: scale(1.25); opacity: 1; }
  }

  @keyframes processingGlow {
    0%, 100% { box-shadow: 0 0 0 rgba(99, 102, 241, 0.12); }
    50% { box-shadow: 0 0 22px rgba(99, 102, 241, 0.35); }
  }

  #agent-processing-indicator {
    border: 1px solid rgba(99, 102, 241, 0.16);
    background: linear-gradient(145deg, rgba(99, 102, 241, 0.08), rgba(191, 219, 254, 0.12));
    backdrop-filter: blur(6px);
    transition: opacity 0.25s ease, transform 0.25s ease;
  }

  #agent-processing-indicator.processing-placeholder--fade {
    opacity: 0;
    transform: translateY(6px);
  }

  .processing-orb {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 2.5rem;
    width: 2.5rem;
    border-radius: 9999px;
    background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    position: relative;
    animation: processingGlow 2.6s ease-in-out infinite;
  }

  .processing-orb__dot {
    height: 0.75rem;
    width: 0.75rem;
    border-radius: 9999px;
    background-color: rgba(255, 255, 255, 0.92);
    animation: processingPulse 1.6s ease-in-out infinite;
  }

  .processing-shimmer {
    border-radius: 9999px;
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.18) 0%, rgba(255, 255, 255, 0.65) 50%, rgba(255, 255, 255, 0.18) 100%);
    background-size: 200% 100%;
    animation: processingShimmer 1.4s ease-in-out infinite;
  }

  .processing-shimmer--lg { height: 1rem; }
  .processing-shimmer--md { height: 0.85rem; }
  .processing-shimmer--sm { height: 0.7rem; }
</style>

<script>
(function () {
  if (window.__agentWorkspaceInitialized) {
    console.debug('[agent-workspace] script already initialized; skipping');
    return;
  }
  window.__agentWorkspaceInitialized = true;

  const root = document.getElementById('agent-workspace-root');
  const log = (...args) => console.debug('[agent-workspace]', ...args);

  if (!root) {
    console.warn('[agent-workspace] root node missing; aborting init.');
    return;
  }

  let attempts = 0;
  const MAX_ATTEMPTS = 20;
  let initialized = false;

  function ready() {
    if (typeof window.htmx === 'undefined') {
      attempts += 1;
      log('htmx wait attempt', { attempts });
      if (attempts === 1) {
        console.warn('[agent-workspace] htmx not yet available; retrying init.');
      }
      if (attempts > MAX_ATTEMPTS) {
        console.error('[agent-workspace] htmx failed to load after retries; realtime disabled.');
        return false;
      }
      window.setTimeout(ready, 150);
      return false;
    }

    log('initializing workspace timeline', { dataset: { newerUrl: root.dataset.timelineNewerUrl, olderUrl: root.dataset.timelineOlderUrl, eventStreamUrl: root.dataset.eventStreamUrl } });
    init();
    return true;
  }

  function init() {
    if (initialized) {
      log('init called after initialization; skipping');
      return;
    }
    initialized = true;

  const timeline = document.getElementById('timeline-events');
  const composer = document.getElementById('agent-web-compose');
  const composerCursor = document.getElementById('composer-latest-cursor');
  const getCursorsEl = () => document.getElementById('timeline-cursors');

  const limit = parseInt(root.dataset.timelineLimit || '150', 10);
  const newerUrl = root.dataset.timelineNewerUrl;
  const eventStreamUrl = root.dataset.eventStreamUrl;

  const state = {
    action: 'idle',
    previousScrollHeight: 0,
    lastEventId: null,
    pendingComposerScroll: false,
    autoScroll: true,
    eventSource: null,
    fetchingNewer: false,
    queuedNewerTrigger: null,
    processingActive: false,
  };
  state.processingActive = root.dataset.processingActive === 'true';

  let reconnectDelay = 3000;
  const RECONNECT_MAX = 30000;

  function isNearBottom() {
    if (!timeline) return true;
    const threshold = 48;
    return timeline.scrollHeight - timeline.scrollTop - timeline.clientHeight <= threshold;
  }

  function scrollToBottom(force) {
    if (!timeline) return;
    if (force || isNearBottom()) {
      timeline.scrollTop = timeline.scrollHeight;
    }
  }

  const PROCESSING_NODE_ID = 'agent-processing-indicator';

  function setProcessingDataset(active) {
    const value = active ? 'true' : 'false';
    root.dataset.processingActive = value;
    const cursorNode = getCursorsEl();
    if (cursorNode) {
      cursorNode.dataset.processingActive = value;
    }
    log('processing.dataset.update', { active: value, rootDataset: root.dataset.processingActive, cursorDataset: cursorNode?.dataset?.processingActive });
  }

  function getProcessingFlag() {
    const cursorNode = getCursorsEl();
    if (cursorNode && typeof cursorNode.dataset.processingActive !== 'undefined') {
      const flag = cursorNode.dataset.processingActive === 'true';
      log('processing.flag.cursor', { flag, dataset: cursorNode.dataset.processingActive });
      return flag;
    }
    const fallback = root.dataset.processingActive === 'true';
    log('processing.flag.root', { fallback, dataset: root.dataset.processingActive });
    return fallback;
  }

  function syncProcessingFromDom() {
    const desired = getProcessingFlag();
    log('processing.sync', { desired, currentState: state.processingActive, hasNode: !!getProcessingNode() });
    const node = getProcessingNode();
    if (desired) {
      if (!state.processingActive || !node) {
        showProcessingIndicator();
      }
    } else if (state.processingActive || node) {
      hideProcessingIndicator();
    }
  }

  function getProcessingNode() {
    return document.getElementById(PROCESSING_NODE_ID);
  }

  function buildProcessingNode() {
    const article = document.createElement('article');
    article.id = PROCESSING_NODE_ID;
    article.className = 'timeline-event timeline-processing bg-white/80 backdrop-blur-sm border border-white/60 shadow-xl rounded-xl overflow-hidden';
    article.innerHTML = `
      <div class="p-6">
        <div class="flex flex-col gap-4 sm:flex-row sm:items-start sm:gap-5">
          <div class="processing-orb"><span class="processing-orb__dot"></span></div>
          <div>
            <p class="text-sm font-semibold text-indigo-600">Agent is crafting a response</p>
            <p class="text-xs text-slate-500">We’ll surface the result the moment it’s ready.</p>
          </div>
        </div>
        <div class="mt-5 space-y-3">
          <div class="processing-shimmer processing-shimmer--lg w-5/6"></div>
          <div class="processing-shimmer processing-shimmer--md w-4/6"></div>
          <div class="processing-shimmer processing-shimmer--sm w-2/5"></div>
        </div>
      </div>`;
    return article;
  }

  function showProcessingIndicator() {
    if (!timeline) return;
    const existing = getProcessingNode();
    if (existing) {
      state.processingActive = true;
      setProcessingDataset(true);
      existing.classList.remove('processing-placeholder--fade');
      timeline.appendChild(existing);
      refreshEmptyState();
      log('processing.show.reuse', { nodeAttached: true });
      return existing;
    }
    const emptyState = timeline.querySelector('.timeline-empty');
    if (emptyState) {
      emptyState.remove();
    }
    const node = buildProcessingNode();
    timeline.appendChild(node);
    state.processingActive = true;
    setProcessingDataset(true);
    refreshEmptyState();
    if (isNearBottom()) {
      scrollToBottom(true);
    }
    log('processing.show.create', { nodeCreated: true });
    return node;
  }

  function hideProcessingIndicator() {
    const node = getProcessingNode();
    if (!node) {
      state.processingActive = false;
      setProcessingDataset(false);
      log('processing.hide.missingNode');
      return;
    }
    state.processingActive = false;
    setProcessingDataset(false);
    node.classList.add('processing-placeholder--fade');
    window.setTimeout(() => {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      ensureEmptyState();
    }, 260);
    log('processing.hide.transition');
  }

  function refreshEmptyState() {
    if (!timeline) return;
    const emptyState = timeline.querySelector('.timeline-empty');
    if (!emptyState) return;
    const hasRealEvents = timeline.querySelector('.timeline-event:not(#agent-processing-indicator)');
    if (hasRealEvents || state.processingActive) {
      emptyState.remove();
    }
  }

  function ensureEmptyState() {
    if (!timeline) return;
    const hasRealEvents = timeline.querySelector('.timeline-event:not(#agent-processing-indicator)');
    if (hasRealEvents || state.processingActive) {
      return;
    }
    if (!timeline.querySelector('.timeline-empty')) {
      const emptyState = document.createElement('div');
      emptyState.className = 'timeline-empty text-center text-sm text-slate-400';
      emptyState.textContent = 'No activity yet.';
      timeline.appendChild(emptyState);
    }
  }

  function updateComposerCursor() {
    const cursorNode = getCursorsEl();
    if (composerCursor && cursorNode) {
      composerCursor.value = cursorNode.dataset.newer || '';
    }
  }

  function updateJumpButton() {
    const btn = document.getElementById('jump-to-latest');
    if (!btn) return;
    const cursorNode = getCursorsEl();
    const hasMoreNewer = cursorNode?.dataset.hasMoreNewer === 'true';
    if (!hasMoreNewer || isNearBottom()) {
      btn.classList.add('hidden');
      return;
    }
    btn.classList.remove('hidden');
  }

  function trimTimeline(direction) {
    if (!timeline) return;
    const nodes = Array.from(timeline.querySelectorAll('.timeline-event')).filter(
      (node) => node.id !== PROCESSING_NODE_ID,
    );
    if (nodes.length <= limit) return;
    const excess = nodes.length - limit;
    log('trimming timeline', { direction, excess });
    if (direction === 'older') {
      for (let i = 0; i < excess; i += 1) {
        const node = nodes[nodes.length - 1 - i];
        if (node) node.remove();
      }
    } else {
      for (let i = 0; i < excess; i += 1) {
        const node = nodes[i];
        if (node) node.remove();
      }
    }
    refreshEmptyState();
  }

  function dedupeTimeline() {
    if (!timeline) return;
    const seen = new Set();
    const items = timeline.querySelectorAll('.timeline-event');
    for (let i = items.length - 1; i >= 0; i -= 1) {
      const node = items[i];
      const cursor = node?.dataset?.cursor;
      if (!cursor) continue;
      if (seen.has(cursor)) {
        node.remove();
      } else {
        seen.add(cursor);
      }
    }
    refreshEmptyState();
  }

  function completeNewerRequest() {
    state.fetchingNewer = false;
    const queuedTrigger = state.queuedNewerTrigger;
    state.queuedNewerTrigger = null;
    if (queuedTrigger) {
      log('consuming queued newer request', { trigger: queuedTrigger });
      requestNewer(queuedTrigger);
    }
  }

  function requestNewer(trigger) {
    if (!newerUrl || !timeline) return;
    if (state.fetchingNewer) {
      state.queuedNewerTrigger = trigger || 'auto-newer';
      log('requestNewer queued', { trigger });
      return;
    }
    const params = new URLSearchParams({ limit: String(limit) });
    const cursorNode = getCursorsEl();
    const cursor = cursorNode?.dataset.newer;
    if (cursor) params.set('cursor', cursor);

    state.action = 'newer';
    state.fetchingNewer = true;
    state.autoScroll = state.pendingComposerScroll ? true : trigger !== 'auto-newer' ? true : isNearBottom();

    log('requestNewer', { trigger, cursor, autoScroll: state.autoScroll });

    window.htmx.ajax('GET', `${newerUrl}&${params.toString()}`, {
      target: '#timeline-events',
      swap: 'beforeend',
    });
  }

  if (timeline) {
    timeline.addEventListener('scroll', () => {
      state.autoScroll = isNearBottom();
      log('scroll', { autoScroll: state.autoScroll });
      updateJumpButton();
    });
  }

  document.addEventListener('click', (event) => {
    const btn = event.target.closest('#jump-to-latest');
    if (!btn) return;
    log('jump-to-latest clicked');
    scrollToBottom(true);
    state.autoScroll = true;
    btn.classList.add('hidden');
  });

  if (composer) {
    composer.addEventListener('htmx:beforeRequest', () => {
      state.pendingComposerScroll = true;
      log('composer submit start');
    });
    composer.addEventListener('htmx:afterRequest', (event) => {
      if (event.detail && event.detail.xhr && event.detail.xhr.status < 400) {
        composer.reset();
        log('composer submit success');
        showProcessingIndicator();
      } else {
        state.pendingComposerScroll = false;
        log('composer submit error', event.detail?.xhr?.status);
      }
    });
  }

  window.htmx.on('htmx:beforeRequest', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;
    const url = event.detail.requestConfig?.path || '';
    log('htmx beforeRequest', { url });
    if (url.includes('direction=older')) {
      state.action = 'older';
      state.previousScrollHeight = timeline?.scrollHeight || 0;
    } else if (url.includes('direction=newer')) {
      state.action = 'newer';
    }
  });

  window.htmx.on('htmx:afterSwap', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;

    log('htmx afterSwap', { action: state.action, autoScroll: state.autoScroll });

    if (state.action === 'older' && timeline) {
      const delta = timeline.scrollHeight - state.previousScrollHeight;
      timeline.scrollTop = Math.max(delta, 0);
    }

    dedupeTimeline();
    trimTimeline(state.action);
    updateComposerCursor();

    // Highlight any new code blocks
    if (typeof Prism !== 'undefined') {
      Prism.highlightAllUnder(timeline);
    }

    if (state.autoScroll) {
      log('auto-scroll applied');
      scrollToBottom(true);
    }

    if (state.action === 'newer' || state.fetchingNewer) {
      completeNewerRequest();
    }

    state.action = 'idle';
    state.previousScrollHeight = 0;
    state.pendingComposerScroll = false;
    state.autoScroll = isNearBottom();
    updateJumpButton();
    refreshEmptyState();
    syncProcessingFromDom();
  });

  window.htmx.on('htmx:afterSettle', (event) => {
    if (event.detail?.target?.id === 'timeline-events') {
      log('htmx afterSettle');
      updateJumpButton();
      refreshEmptyState();
      syncProcessingFromDom();
    }
  });

  window.htmx.on('htmx:responseError', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;
    log('htmx responseError', { status: event.detail.xhr?.status });
    completeNewerRequest();
  });

  window.htmx.on('htmx:sendError', (event) => {
    if (event.detail?.target?.id !== 'timeline-events') return;
    log('htmx sendError');
    completeNewerRequest();
  });

  const handleProcessingStartedEvent = (evt) => {
    if (evt?.lastEventId) {
      state.lastEventId = evt.lastEventId;
    }
    reconnectDelay = 3000;
    log('SSE processing.started', { lastId: evt?.lastEventId });
    showProcessingIndicator();
  };

  const handleProcessingFinishedEvent = (evt) => {
    if (evt?.lastEventId) {
      state.lastEventId = evt.lastEventId;
    }
    reconnectDelay = 3000;
    log('SSE processing.finished', { lastId: evt?.lastEventId });
    hideProcessingIndicator();
    requestNewer('processing-finished');
  };

  function connectEventStream(lastId) {
    if (!eventStreamUrl) {
      console.warn('[agent-workspace] Missing eventStreamUrl dataset attribute; realtime updates disabled.');
      return;
    }

    if (typeof window.EventSource === 'undefined') {
      console.warn('[agent-workspace] EventSource API unavailable; realtime updates disabled.');
      return;
    }

    let cursor = lastId;
    if (cursor && !/^[0-9]+-[0-9]+$/.test(cursor)) {
      log('invalid_last_event_id_format', { cursor });
      cursor = null;
    }

    const url = cursor ? `${eventStreamUrl}?cursor=${encodeURIComponent(cursor)}` : eventStreamUrl;
    log('connecting SSE', { url, cursor });
    const source = new EventSource(url);

    source.onopen = () => {
      log('SSE open');
    };

    const handleMessage = (evt) => {
      if (evt.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      log('SSE message', { event: evt.type || 'message', lastId: evt.lastEventId });
      requestNewer('auto-newer');
    };

    source.addEventListener('message', handleMessage);
    source.addEventListener('step.created', handleMessage);
    source.addEventListener('message.created', handleMessage);
    source.addEventListener('processing.started', handleProcessingStartedEvent);
    source.addEventListener('processing.finished', handleProcessingFinishedEvent);
    source.onerror = (err) => {
      log('SSE error', err);
      source.close();
      state.eventSource = null;
      reconnectDelay = Math.min(Math.round(reconnectDelay * 1.5), RECONNECT_MAX);
      log('SSE reconnect scheduled', reconnectDelay);
      window.setTimeout(() => connectEventStream(state.lastEventId), reconnectDelay);
      hideProcessingIndicator();
    };

    state.eventSource = source;
  }

  const initialCursor = getCursorsEl()?.dataset.newer || null;
  log('workspace init', { cursor: initialCursor });
  syncProcessingFromDom();
  syncProcessingFromDom();
  connectEventStream(null);
  scrollToBottom(true);
  updateJumpButton();
  refreshEmptyState();

  // Highlight any existing code blocks
  if (typeof Prism !== 'undefined') {
    Prism.highlightAllUnder(timeline);
  }

  window.addEventListener('beforeunload', () => {
    if (state.eventSource) {
      log('closing SSE before unload');
      state.eventSource.close();
      state.eventSource = null;
    }
  });
  }

  ready();
})();
</script>
{% endblock %}
