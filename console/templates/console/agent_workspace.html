{% extends "base.html" %}
{% load static %}
{% load agent_extras %}

{% block global_header %}{% endblock %}
{% block global_footer %}{% endblock %}

{% block content %}
<main class="min-h-screen bg-slate-50">
  <div class="mx-auto flex min-h-screen w-full flex-col gap-6 px-4 pb-0 pt-6 sm:px-6 lg:px-10">

    <div id="agent-workspace-root"
         class="relative flex flex-1 flex-col gap-4"
         data-timeline-limit="{{ timeline_limit }}"
         data-timeline-newer-url="{{ timeline_newer_url }}"
         data-timeline-older-url="{{ timeline_older_url }}"
         data-event-stream-url="{{ event_stream_url }}"
         data-processing-active="{{ processing_active|yesno:'true,false' }}"
         data-agent-first-name="{{ agent_first_name }}">

      <div id="timeline-shell" class="relative flex-1">
        <div id="timeline-events" class="flex h-full flex-col gap-3 overflow-y-auto">
          <div class="flex justify-center py-2 text-xs text-slate-500">
            {% if timeline_window.has_more_older %}
              <button
                class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-medium text-slate-600 shadow-sm transition hover:bg-slate-50"
                hx-get="{{ timeline_older_url }}{% if timeline_window.window_oldest_cursor %}&cursor={{ timeline_window.window_oldest_cursor|urlencode }}{% endif %}&limit={{ timeline_limit }}&current_newest={{ timeline_window.window_newest_cursor|default:''|urlencode }}"
                hx-target="#timeline-events"
                hx-swap="afterbegin">
                Load older
              </button>
            {% endif %}
          </div>
          {% include "console/partials/_agent_timeline_items.html" with events=timeline_window.events agent_first_name=agent_first_name %}
          <div id="processing-indicator-slot" class="mt-2 px-1"></div>
        </div>
      </div>

      <div id="timeline-cursors" class="hidden"
           data-older="{{ timeline_window.window_oldest_cursor|default:'' }}"
           data-newer="{{ timeline_window.window_newest_cursor|default:'' }}"
           data-has-more-older="{{ timeline_window.has_more_older|yesno:'true,false' }}"
           data-has-more-newer="{{ timeline_window.has_more_newer|yesno:'true,false' }}"
           data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>

      <div id="agent-composer-shell" class="composer-shell">
        <div class="composer-surface">
          <form id="agent-web-compose" class="flex flex-col" hx-post="{% url 'agent_web_message' agent.id %}" hx-swap="none">
            <div class="flex flex-col gap-2 rounded-3xl border border-slate-200 bg-white/95 px-2.5 py-2.5 shadow-md transition focus-within:border-indigo-500 focus-within:ring-2 focus-within:ring-indigo-500/20">
              <textarea name="body" rows="1" required
                        class="block w-full resize-none border-0 bg-transparent px-0 py-0.5 text-sm leading-5 text-slate-800 placeholder:text-slate-400 focus:outline-none focus:ring-0 min-h-[1.8rem]"
                        placeholder="Send a message..."></textarea>
              <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div class="flex flex-col gap-1.5 text-xs text-slate-500 sm:flex-row sm:items-center sm:gap-3.5">
                  <div class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white px-2 py-0.5 text-[0.72rem] text-slate-500 shadow-sm sm:text-sm">
                    <span class="uppercase tracking-wide text-[0.7rem] text-slate-400">Sending to</span>
                    <span class="font-medium text-slate-900">{{ agent.name }}</span>
                  </div>
                  <a href="{% url 'agents' %}"
                     class="inline-flex items-center gap-1.5 text-[0.75rem] text-slate-500 transition hover:text-indigo-600 sm:text-sm">
                    <svg class="h-3.5 w-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    Back to agents
                  </a>
                </div>
                <button type="submit"
                        class="inline-flex items-center justify-center rounded-xl bg-indigo-600 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                  Send
                </button>
              </div>
            </div>
            <input type="hidden" name="current_newest" id="composer-latest-cursor" value="{{ timeline_window.window_newest_cursor|default:'' }}">
          </form>
        </div>
      </div>
    </div>
  </div>
</main>
<button id="jump-to-latest" class="jump-to-latest hidden" type="button" aria-label="Jump to latest" aria-hidden="true" style="display:none;opacity:0">
  <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 5v14m0 0-5-5m5 5 5-5" />
  </svg>
  <span class="sr-only">Jump to latest</span>
</button>
<div id="processing-state" class="hidden" style="display:none" data-processing-active="{{ processing_active|yesno:'true,false' }}"></div>
{% endblock %}

{% block extra_js %}
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<style>
  #agent-workspace-root {
    min-height: 24rem;
  }

  #timeline-shell {
    width: 100%;
    max-width: 82rem;
    margin: 0 auto;
  }

  #timeline-events {
    padding: 1rem 0.75rem var(--timeline-bottom-padding, 9rem);
  }

  #timeline-events.timeline-align-end {
    justify-content: flex-end;
  }

  #timeline-events::-webkit-scrollbar {
    width: 8px;
  }

  #timeline-events::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.4);
    border-radius: 9999px;
  }

  #processing-indicator-slot {
    display: flex;
    justify-content: flex-start;
    pointer-events: none;
  }

  #agent-processing-indicator {
    display: inline-flex;
    align-items: center;
    gap: 0.65rem;
    border-radius: 9999px;
    padding: 0.5rem 0.85rem;
    background: rgba(99, 102, 241, 0.12);
    color: #312e81;
    font-size: 0.8rem;
    font-weight: 500;
    box-shadow: 0 4px 14px rgba(99, 102, 241, 0.12);
    border: 1px solid rgba(99, 102, 241, 0.18);
    transition: opacity 0.22s ease, transform 0.22s ease;
  }

  #agent-processing-indicator.processing-indicator--fade {
    opacity: 0;
    transform: translateY(6px);
  }

  .processing-pip {
    width: 0.6rem;
    height: 0.6rem;
    border-radius: 9999px;
    background: #4f46e5;
    box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.4);
    animation: processingPulse 1.6s ease-in-out infinite;
  }

  .processing-label strong {
    font-weight: 600;
  }

  @keyframes processingPulse {
    0% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.48);
    }
    70% {
      transform: scale(1.12);
      box-shadow: 0 0 0 6px rgba(79, 70, 229, 0);
    }
    100% {
      transform: scale(0.9);
      box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
    }
  }

  .composer-shell {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0.75rem;
    display: flex;
    justify-content: center;
    padding: 0 1.25rem;
    z-index: 40;
    pointer-events: none;
  }

  .composer-surface {
    width: 100%;
    max-width: min(60rem, calc(100% - 2.5rem));
    padding: 0;
    background: transparent;
    border: 0;
    box-shadow: none;
    pointer-events: auto;
  }

  .jump-to-latest {
    position: fixed;
    left: 50%;
    z-index: 50;
    width: 3.25rem;
    height: 3.25rem;
    bottom: 9rem;
    border-radius: 9999px;
    border: 1px solid rgba(79, 70, 229, 0.2);
    background: #ffffff;
    color: #4f46e5;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 12px 32px rgba(79, 70, 229, 0.18);
    transform: translate(-50%, 0);
    transition: transform 0.18s ease, box-shadow 0.18s ease, opacity 0.15s ease;
  }

  .jump-to-latest svg {
    width: 1.25rem;
    height: 1.25rem;
  }

  .jump-to-latest:hover {
    transform: translate(-50%, -4px);
    box-shadow: 0 16px 36px rgba(79, 70, 229, 0.24);
  }

  .jump-to-latest:focus-visible {
    outline: 3px solid rgba(59, 130, 246, 0.35);
    outline-offset: 2px;
  }

  .chat-event {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    width: 100%;
  }

  .timeline-event {
    position: relative;
  }

  .timeline-event--incoming {
    animation: timelineEventIncoming 260ms cubic-bezier(0.16, 1, 0.3, 1);
  }

  .timeline-event--incoming .chat-bubble {
    animation: timelineEventBubbleHighlight 340ms cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes timelineEventIncoming {
    0% {
      opacity: 0;
      transform: translateY(12px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes timelineEventBubbleHighlight {
    0% {
      box-shadow: 0 18px 40px rgba(79, 70, 229, 0.22);
    }
    100% {
      box-shadow: 0 6px 20px rgba(15, 23, 42, 0.12);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .timeline-event--incoming {
      animation-duration: 1ms;
      animation-iteration-count: 1;
      animation-timing-function: linear;
    }

    .timeline-event--incoming .chat-bubble {
      animation-duration: 1ms;
      animation-iteration-count: 1;
      animation-timing-function: linear;
    }
  }

  .chat-event.is-user {
    align-items: flex-end;
  }

  .chat-event.is-agent {
    align-items: flex-start;
  }

  .chat-bubble {
    /* allow messages to use more horizontal space on wide screens while remaining readable */
    max-width: min(60rem, 100%);
    border-radius: 1.25rem;
    padding: 1rem 1.25rem;
    font-size: 0.9375rem;
    line-height: 1.5;
    box-shadow: 0 6px 20px rgba(15, 23, 42, 0.12);
  }

  .chat-content {
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  .tool-cluster {
    background: transparent;
    border: none;
    box-shadow: none;
  }

  .tool-cluster-shell {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .tool-chip-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    align-items: flex-start;
  }

  .tool-chip {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.45rem;
    flex: 0 0 auto;
  }

  .tool-chip-trigger {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    border-radius: 9999px;
    border: 1px solid rgba(203, 213, 225, 0.6);
    background: rgba(248, 250, 252, 0.92);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
    padding: 0.35rem 0.7rem;
    font-size: 0.75rem;
    font-weight: 600;
    color: #1f2937;
    transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
    cursor: pointer;
  }

  .tool-chip-trigger:hover,
  .tool-chip-trigger:focus-visible {
    border-color: rgba(99, 102, 241, 0.35);
    box-shadow: 0 4px 14px rgba(99, 102, 241, 0.16);
    outline: none;
  }

  .tool-chip.is-open .tool-chip-trigger {
    border-color: rgba(99, 102, 241, 0.45);
    box-shadow: 0 6px 18px rgba(99, 102, 241, 0.22);
    background: rgba(238, 242, 255, 0.92);
  }

  .tool-chip-icon {
    display: grid;
    place-items: center;
    width: 1.65rem;
    height: 1.65rem;
    border-radius: 9999px;
    flex-shrink: 0;
  }

  .tool-chip-body {
    display: flex;
    flex-direction: column;
    gap: 0.1rem;
  }

  .tool-chip-label {
    font-size: 0.74rem;
    font-weight: 600;
    color: #0f172a;
  }

  .tool-chip-caption {
    font-size: 0.68rem;
    color: #64748b;
  }

  .tool-chip-detail {
    width: min(30rem, 100%);
    border-radius: 1rem;
    border: 1px solid rgba(203, 213, 225, 0.6);
    background: rgba(255, 255, 255, 0.97);
    box-shadow: 0 14px 34px rgba(15, 23, 42, 0.16);
    padding: 0.85rem 1rem 1rem;
  }

  .tool-cluster-detail-host {
    width: 100%;
    margin-top: 0.65rem;
  }

  .tool-cluster-detail-host[hidden] {
    display: none;
  }

  .tool-cluster-timestamp {
    align-self: flex-start;
    margin-top: 0.25rem;
    margin-left: 0.15rem;
  }

  .tool-chip-detail-header {
    display: flex;
    align-items: flex-start;
    gap: 0.55rem;
  }

  .tool-chip-detail-icon {
    display: grid;
    place-items: center;
    width: 1.9rem;
    height: 1.9rem;
    border-radius: 9999px;
    flex-shrink: 0;
  }

  .tool-chip-detail-text {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    min-width: 0;
  }

  .tool-chip-detail-label {
    font-size: 0.85rem;
    font-weight: 600;
    color: #0f172a;
  }

  .tool-chip-detail-meta {
    font-size: 0.7rem;
    color: #64748b;
  }

  .tool-chip-close {
    margin-left: auto;
    background: transparent;
    border: none;
    color: #94a3b8;
    padding: 0.15rem;
    border-radius: 0.45rem;
    cursor: pointer;
    transition: color 0.18s ease, background-color 0.18s ease;
  }

  .tool-chip-close:hover,
  .tool-chip-close:focus-visible {
    color: #475569;
    background-color: rgba(148, 163, 184, 0.18);
    outline: none;
  }

  .tool-chip-panel {
    margin-top: 0.75rem;
    border-radius: 0.9rem;
    border: 1px solid rgba(226, 232, 240, 0.6);
    background: rgba(248, 249, 255, 0.96);
    padding: 0.85rem 0.95rem;
    font-size: 0.8rem;
    color: #475569;
    max-height: min(28rem, 55vh);
    overflow-y: auto;
  }

  .tool-chip-panel-title {
    font-size: 0.72rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: #4f46e5;
  }

  .tool-chip-panel-body {
    margin-top: 0.35rem;
    font-size: 0.86rem;
    color: #334155;
  }

  .chat-bubble--user {
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: #fbfbff;
  }

  .chat-bubble--agent {
    background: rgba(248, 249, 255, 0.95);
    color: #1e1b4b;
    border: 1px solid rgba(79, 70, 229, 0.12);
  }

  .chat-author {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    margin-bottom: 0.35rem;
  }

  .chat-author--user {
    color: rgba(255, 255, 255, 0.75);
  }

  .chat-author--agent {
    color: rgba(79, 70, 229, 0.65);
  }

  .chat-meta {
    margin-top: 0.6rem;
    font-size: 0.7rem;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.9);
  }

  .chat-meta.is-user {
    color: rgba(148, 163, 184, 0.9);
    text-align: right;
    align-self: flex-end;
  }

  .chat-attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.75rem;
  }

  .chat-attachments a {
    display: inline-flex;
    align-items: center;
    gap: 0.45rem;
    border-radius: 9999px;
    padding: 0.35rem 0.75rem;
    font-size: 0.75rem;
    text-decoration: none;
    transition: background 0.18s ease;
  }

  .chat-bubble--agent .chat-attachments a {
    background: rgba(79, 70, 229, 0.08);
    color: #4338ca;
  }

  .chat-bubble--user .chat-attachments a {
    background: rgba(255, 255, 255, 0.2);
    color: #ede9fe;
  }

  .chat-bubble--agent .chat-attachments a:hover {
    background: rgba(79, 70, 229, 0.12);
  }

  .chat-bubble--user .chat-attachments a:hover {
    background: rgba(255, 255, 255, 0.28);
  }

  @media (max-width: 768px) {
    .composer-shell {
      padding: 0 0.85rem;
      bottom: 1rem;
    }

    .composer-surface {
      padding: 0;
      box-shadow: none;
    }

    #timeline-events {
      padding-bottom: 14rem;
    }

    .jump-to-latest {
      width: 2.85rem;
      height: 2.85rem;
      bottom: 8rem;
      box-shadow: 0 10px 26px rgba(79, 70, 229, 0.2);
    }

    .chat-bubble {
      max-width: 95%;
      font-size: 0.9rem;
    }
  }
</style>

<script>
(function () {
  if (window.__agentWorkspaceInitialized) {
    console.debug('[agent-workspace] script already initialized; skipping');
    return;
  }
  window.__agentWorkspaceInitialized = true;

  const root = document.getElementById('agent-workspace-root');

  if (!root) {
    console.warn('[agent-workspace] root node missing; aborting init.');
    return;
  }

  let attempts = 0;
  const MAX_ATTEMPTS = 20;
  let initialized = false;

  function ready() {
    if (typeof window.htmx === 'undefined') {
      attempts += 1;
      if (attempts === 1) {
        console.warn('[agent-workspace] htmx not yet available; retrying init.');
      }
      if (attempts > MAX_ATTEMPTS) {
        console.error('[agent-workspace] htmx failed to load after retries; realtime disabled.');
        return false;
      }
      window.setTimeout(ready, 150);
      return false;
    }

    init();
    return true;
  }

  function init() {
    if (initialized) {
      return;
    }
    initialized = true;

    const timeline = document.getElementById('timeline-events');
    const processingSlot = document.getElementById('processing-indicator-slot');
    const composer = document.getElementById('agent-web-compose');
    const composerCursor = document.getElementById('composer-latest-cursor');
    const composerSurface = document.querySelector('.composer-surface');
    const getJumpButton = () => document.getElementById('jump-to-latest');
    const agentFirstName = root.dataset.agentFirstName || 'Your agent';
    const getCursorsEl = () => document.getElementById('timeline-cursors');

    const limit = parseInt(root.dataset.timelineLimit || '150', 10);
    const newerUrl = root.dataset.timelineNewerUrl;
    const eventStreamUrl = root.dataset.eventStreamUrl;

    const initialProcessingActive = root.dataset.processingActive === 'true';

    const composerShell = document.querySelector('.composer-shell');

    const state = {
      action: 'idle',
      previousScrollHeight: 0,
      lastEventId: null,
      pendingComposerScroll: false,
      autoScroll: true,
      eventSource: null,
      fetchingNewer: false,
      queuedNewerTrigger: null,
      processingActive: initialProcessingActive,
      bottomAnchorOffset: null,
      pageBottomOffset: null,
      knownCursors: new Set(),
      processingSticky: initialProcessingActive,
    };

    const JUMP_BUTTON_SIZE = 52; // matches 3.25rem
    const JUMP_BUTTON_GAP = 18;
    const BASE_SCROLL_THRESHOLD = 140;
    const ALIGN_THRESHOLD = 160;
    const BOTTOM_ANCHOR_THRESHOLD = 48;

    let openToolChip = null;

    function closeOpenToolChip(options = {}) {
      if (!openToolChip) return;
      const cluster = openToolChip.closest('.tool-cluster-shell');
      const host = cluster?.querySelector('.tool-cluster-detail-host');
      const trigger = openToolChip.querySelector('.tool-chip-trigger');
      const detailId = openToolChip.dataset.detailId || trigger?.getAttribute('aria-controls');
      let detail = null;
      if (detailId) {
        detail = cluster?.querySelector(`#${detailId}`) || document.getElementById(detailId);
      }

      if (trigger) {
        trigger.setAttribute('aria-expanded', 'false');
      }

      if (detail) {
        detail.hidden = true;
        if (host && detail.parentElement === host) {
          host.removeChild(detail);
        }
        openToolChip.appendChild(detail);
      }

      if (host && host.childElementCount === 0) {
        host.innerHTML = '';
        host.hidden = true;
      }

      openToolChip.classList.remove('is-open');
      delete openToolChip.dataset.detailId;

      if (options.restoreFocus && trigger) {
        trigger.focus();
      }

      openToolChip = null;
    }

    function openToolChipDetail(chip) {
      if (!chip) return;

      if (chip === openToolChip) {
        closeOpenToolChip({ restoreFocus: true });
        return;
      }

      const cluster = chip.closest('.tool-cluster-shell');
      const host = cluster?.querySelector('.tool-cluster-detail-host');
      const trigger = chip.querySelector('.tool-chip-trigger');
      const detailId = trigger?.getAttribute('aria-controls');

      if (!cluster || !host || !trigger || !detailId) {
        closeOpenToolChip();
        return;
      }

      let detail = cluster.querySelector(`#${detailId}`) || document.getElementById(detailId);
      if (!detail) {
        closeOpenToolChip();
        return;
      }

      closeOpenToolChip();

      chip.classList.add('is-open');
      chip.dataset.detailId = detailId;
      trigger.setAttribute('aria-expanded', 'true');

      detail.hidden = false;
      host.hidden = false;
      host.innerHTML = '';
      host.appendChild(detail);

      openToolChip = chip;

      window.requestAnimationFrame(() => {
        const closeBtn = detail.querySelector('.tool-chip-close');
        if (closeBtn && typeof closeBtn.focus === 'function') {
          closeBtn.focus();
        }
        if (typeof detail.scrollIntoView === 'function') {
          detail.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      });
    }

    function getTimelineBottomOffset() {
      if (!timeline) return 0;
      return timeline.scrollHeight - timeline.scrollTop - timeline.clientHeight;
    }

    function updateTimelinePadding() {
      if (!timeline) return;
      const composerHeight = composerSurface?.offsetHeight || 0;
      const slack = Math.max(timeline.scrollHeight - timeline.clientHeight, 0);
      const fewEvents = timeline.querySelectorAll('.timeline-event[data-cursor]').length <= 6;
      const shouldAlignEnd = slack <= ALIGN_THRESHOLD && fewEvents;
      const timelineStyles = window.getComputedStyle(timeline);
      const rowGap = parseFloat(timelineStyles.rowGap || timelineStyles.gap || '0') || 12;
      const composerBottomOffset = composerShell
        ? parseFloat(window.getComputedStyle(composerShell).bottom || '24') || 24
        : 24;

      const basePadding = composerHeight + composerBottomOffset + rowGap;
      let padding;
      if (shouldAlignEnd) {
        padding = basePadding;
      } else {
        const relaxedGap = Math.max(rowGap, 24);
        const compactPadding = composerHeight + composerBottomOffset + relaxedGap;
        padding = Math.max(compactPadding, basePadding);
      }
      timeline.style.setProperty('--timeline-bottom-padding', `${Math.round(padding)}px`);

      timeline.classList.toggle('timeline-align-end', shouldAlignEnd);
    }

    function positionJumpButton() {
      const button = getJumpButton();
      if (!button || !composerSurface) return;
      const rect = composerSurface.getBoundingClientRect();
      const buttonHeight = button.offsetHeight || JUMP_BUTTON_SIZE;
      const desiredTop = rect.top - (buttonHeight + JUMP_BUTTON_GAP);
      const boundedTop = Math.max(desiredTop, 16);
      button.style.top = `${Math.round(boundedTop)}px`;
      button.style.bottom = 'auto';
    }

    function toggleJumpButtonVisibility(visible) {
      const button = getJumpButton();
      if (!button) return;
      if (visible) {
        button.classList.remove('hidden');
        button.setAttribute('aria-hidden', 'false');
        button.style.opacity = '1';
        button.style.display = 'flex';
        window.requestAnimationFrame(positionJumpButton);
      } else {
        button.style.opacity = '0';
        button.classList.add('hidden');
        button.setAttribute('aria-hidden', 'true');
        button.style.display = 'none';
      }
    }

    function isTimelineScrollable() {
      if (!timeline) return false;
      return timeline.scrollHeight - timeline.clientHeight > 1;
    }

    function getScrollThreshold() {
      const composerHeight = composerSurface?.offsetHeight || 0;
      const threshold = Math.max(BASE_SCROLL_THRESHOLD, Math.min(composerHeight + 160, 600));
      return threshold;
    }

    function getPageBottomOffset() {
      const doc = document.documentElement || document.body;
      const body = document.body || { scrollHeight: 0, offsetHeight: 0 };
      const totalHeight = Math.max(
        doc?.scrollHeight || 0,
        doc?.offsetHeight || 0,
        body.scrollHeight || 0,
        body.offsetHeight || 0
      );
      const viewportHeight = window.innerHeight || doc?.clientHeight || 0;
      const scrollY = window.scrollY ?? doc?.scrollTop ?? 0;
      const offset = totalHeight - (scrollY + viewportHeight);
      return offset;
    }

    // Smoothly maintain the page's distance from the bottom when new content arrives.
    function scrollPageToBottomOffset(offset, behavior) {
      const doc = document.documentElement || document.body;
      const body = document.body || { scrollHeight: 0, offsetHeight: 0 };
      const totalHeight = Math.max(
        doc?.scrollHeight || 0,
        doc?.offsetHeight || 0,
        body.scrollHeight || 0,
        body.offsetHeight || 0
      );
      const viewportHeight = window.innerHeight || doc?.clientHeight || 0;
      const target = Math.max(totalHeight - viewportHeight - Math.max(offset || 0, 0), 0);
      const config = { top: target, behavior };
      try {
        window.scrollTo(config);
      } catch (err) {
        window.scrollTo(0, target);
      }
    }

    function isNearBottom() {
      if (!timeline) {
        return true;
      }

      const threshold = getScrollThreshold();

      if (isTimelineScrollable()) {
        const bottomOffset = getTimelineBottomOffset();
        const nearTimeline = bottomOffset <= threshold;
        return nearTimeline;
      }

      const pageOffset = Math.max(getPageBottomOffset(), 0);
      const nearPage = pageOffset <= threshold;
      return nearPage;
    }

    let reconnectDelay = 3000;
    const RECONNECT_MAX = 30000;

    function ensureProcessingSlotPosition() {
      if (!timeline || !processingSlot) return;
      if (processingSlot.parentNode !== timeline) {
        timeline.appendChild(processingSlot);
        return;
      }
      if (timeline.lastElementChild !== processingSlot) {
        timeline.appendChild(processingSlot);
      }
    }

    function scrollToBottom(arg) {
      if (!timeline) return;

      const hasOptions = typeof arg === 'object' && arg !== null;
      const force = hasOptions ? Boolean(arg.force) : Boolean(arg);
      const nearBefore = isNearBottom();
      if (!force && !nearBefore) return;

      const prefersReducedMotion = Boolean(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
      const defaultTimelineBehavior = prefersReducedMotion ? 'auto' : 'smooth';
      const timelineBehavior = hasOptions && arg.behavior ? arg.behavior : defaultTimelineBehavior;
      const defaultPageBehavior = prefersReducedMotion ? 'auto' : (nearBefore ? 'auto' : 'smooth');
      const pageBehavior = hasOptions && arg.pageBehavior ? arg.pageBehavior : defaultPageBehavior;
      const alignPage = hasOptions ? arg.alignPage !== false : true;
      const desiredPageOffset = hasOptions && typeof arg.pageOffset === 'number' ? arg.pageOffset : null;

      const targetTop = Math.max(timeline.scrollHeight - timeline.clientHeight, 0);
      if (typeof timeline.scrollTo === 'function') {
        timeline.scrollTo({ top: targetTop, behavior: timelineBehavior });
      } else {
        timeline.scrollTop = targetTop;
      }

      state.autoScroll = true;

      if (!alignPage) {
        return;
      }

      const currentOffset = getPageBottomOffset();
      const targetOffset = desiredPageOffset !== null ? desiredPageOffset : 0;
      if (Math.abs(targetOffset - currentOffset) > 1) {
        scrollPageToBottomOffset(targetOffset, pageBehavior);
      }
    }

    const PROCESSING_NODE_ID = 'agent-processing-indicator';

    function setProcessingDataset(active) {
      const value = active ? 'true' : 'false';
      root.dataset.processingActive = value;
      const cursorNode = getCursorsEl();
      if (cursorNode) {
        cursorNode.dataset.processingActive = value;
      }
    }

    function getProcessingFlag() {
      const cursorNode = getCursorsEl();
      if (cursorNode && typeof cursorNode.dataset.processingActive !== 'undefined') {
        const flag = cursorNode.dataset.processingActive === 'true';
        return flag;
      }
      const fallback = root.dataset.processingActive === 'true';
      return fallback;
    }

    function syncProcessingFromDom() {
      ensureProcessingSlotPosition();
      const desired = getProcessingFlag();
      const node = getProcessingNode();
      if (desired) {
        if (!state.processingActive || !node) {
          showProcessingIndicator();
        }
      } else if (!state.processingSticky && (state.processingActive || node)) {
        hideProcessingIndicator();
      }
    }

    function getProcessingNode() {
      if (!processingSlot) return null;
      return processingSlot.querySelector(`#${PROCESSING_NODE_ID}`);
    }

    function buildProcessingNode() {
      const pill = document.createElement('div');
      pill.id = PROCESSING_NODE_ID;
      pill.className = 'processing-indicator';
      pill.innerHTML = `
        <span class="processing-pip" aria-hidden="true"></span>
        <span class="processing-label"><strong>${agentFirstName}</strong> is working</span>
      `;
      return pill;
    }

    function showProcessingIndicator(options = {}) {
      if (!processingSlot) return;
      ensureProcessingSlotPosition();
      let indicator = getProcessingNode();
      if (!indicator) {
        processingSlot.innerHTML = '';
        indicator = buildProcessingNode();
        processingSlot.appendChild(indicator);
      } else {
        indicator.classList.remove('processing-indicator--fade');
      }
      state.processingActive = true;
      if (options && options.sticky) {
        state.processingSticky = true;
      }
      setProcessingDataset(true);
      refreshEmptyState();
      if (isNearBottom()) {
        scrollToBottom({ force: true });
      }
    }

    function hideProcessingIndicator() {
      const indicator = getProcessingNode();
      if (!indicator) {
        state.processingActive = false;
        state.processingSticky = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
        return;
      }
      indicator.classList.add('processing-indicator--fade');
      window.setTimeout(() => {
        indicator.remove();
        state.processingActive = false;
        state.processingSticky = false;
        setProcessingDataset(false);
        refreshEmptyState();
        ensureEmptyState();
      }, 220);
    }

    function refreshEmptyState() {
      if (!timeline) return;
      const emptyState = timeline.querySelector('.timeline-empty');
      if (!emptyState) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        emptyState.remove();
      }
    }

    function ensureEmptyState() {
      if (!timeline) return;
      const hasRealEvents = timeline.querySelector('.timeline-event[data-cursor]');
      if (hasRealEvents || state.processingActive) {
        return;
      }
      if (!timeline.querySelector('.timeline-empty')) {
        const emptyState = document.createElement('div');
        emptyState.className = 'timeline-empty text-center text-sm text-slate-400';
        emptyState.textContent = 'No activity yet.';
        timeline.appendChild(emptyState);
      }
    }

    function updateComposerCursor() {
      const cursorNode = getCursorsEl();
      if (composerCursor && cursorNode) {
        composerCursor.value = cursorNode.dataset.newer || '';
      }
    }

    function updateJumpButton() {
      const button = getJumpButton();
      if (!button) return;
      positionJumpButton();
      const show = !isNearBottom();
      toggleJumpButtonVisibility(show);
    }

    function forgetCursor(node) {
      if (!node || !state.knownCursors) return;
      const cursor = node.dataset?.cursor;
      if (!cursor) return;
      state.knownCursors.delete(cursor);
    }

    function syncKnownCursors(options = {}) {
      if (!timeline) return;
      const animate = Boolean(options.animate);
      if (!state.knownCursors) {
        state.knownCursors = new Set();
      }

      const items = timeline.querySelectorAll('.timeline-event[data-cursor]');
      const newcomers = [];

      items.forEach((node) => {
        const cursor = node.dataset?.cursor;
        if (!cursor) return;
        if (!state.knownCursors.has(cursor)) {
          state.knownCursors.add(cursor);
          if (animate) {
            newcomers.push(node);
          }
        }
      });

      if (animate && newcomers.length) {
        window.requestAnimationFrame(() => {
          newcomers.forEach((node) => {
            node.classList.add('timeline-event--incoming');
            const cleanup = () => {
              node.classList.remove('timeline-event--incoming');
              node.removeEventListener('animationend', cleanup);
            };
            node.addEventListener('animationend', cleanup, { once: true });
            window.setTimeout(cleanup, 900);
          });
        });
      }
    }

    function trimTimeline(direction) {
      if (!timeline) return;
      const nodes = Array.from(timeline.querySelectorAll('.timeline-event[data-cursor]'));
      if (nodes.length <= limit) return;

      const excess = nodes.length - limit;
      const removingFromTop = direction !== 'older';
      let restoreScroll = false;
      let previousBottomOffset = 0;

      if (removingFromTop) {
        const autoScrollActive = state.autoScroll || isNearBottom();
        if (autoScrollActive) {
          restoreScroll = true;
          previousBottomOffset = timeline.scrollHeight - timeline.scrollTop;
        }
      }

      if (direction === 'older') {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[nodes.length - 1 - i];
          if (node) {
            forgetCursor(node);
            node.remove();
          }
        }
      } else {
        for (let i = 0; i < excess; i += 1) {
          const node = nodes[i];
          if (node) {
            forgetCursor(node);
            node.remove();
          }
        }
      }

      if (restoreScroll) {
        const target = Math.max(timeline.scrollHeight - previousBottomOffset, 0);
        if (typeof timeline.scrollTo === 'function') {
          timeline.scrollTo({ top: target, behavior: 'auto' });
        } else {
          timeline.scrollTop = target;
        }
      }

      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function dedupeTimeline() {
      if (!timeline) return;
      const seen = new Set();
      const items = timeline.querySelectorAll('.timeline-event[data-cursor]');
      for (let i = items.length - 1; i >= 0; i -= 1) {
        const node = items[i];
        const cursor = node?.dataset?.cursor;
        if (!cursor) continue;
        if (seen.has(cursor)) {
          forgetCursor(node);
          node.remove();
        } else {
          seen.add(cursor);
        }
      }
      ensureProcessingSlotPosition();
      refreshEmptyState();
    }

    function completeNewerRequest() {
      state.fetchingNewer = false;
      const queuedTrigger = state.queuedNewerTrigger;
      state.queuedNewerTrigger = null;
      if (queuedTrigger) {
        requestNewer(queuedTrigger);
      }
    }

    function requestNewer(trigger) {
      if (!newerUrl || !timeline) return;
      if (state.fetchingNewer) {
        state.queuedNewerTrigger = trigger || 'auto-newer';
        return;
      }
      const params = new URLSearchParams({ limit: String(limit) });
      const cursorNode = getCursorsEl();
      const cursor = cursorNode?.dataset.newer;
      if (cursor) params.set('cursor', cursor);

      state.action = 'newer';
      state.fetchingNewer = true;
      const nearBottom = isNearBottom();
      state.autoScroll = state.pendingComposerScroll ? true : nearBottom;

      window.htmx.ajax('GET', `${newerUrl}&${params.toString()}`, {
        target: '#timeline-events',
        swap: 'beforeend',
      });
    }

    if (timeline) {
      timeline.addEventListener('scroll', () => {
        const nearBottom = isNearBottom();
        state.autoScroll = nearBottom;
        updateJumpButton();
      });
    }

    const handleWindowScroll = () => {
      const nearBottom = isNearBottom();
      state.autoScroll = nearBottom;
      updateJumpButton();
    };

    window.addEventListener('scroll', handleWindowScroll, { passive: true });

    const handleResize = () => {
      updateTimelinePadding();
      positionJumpButton();
      updateJumpButton();
    };

    const handleOrientationChange = () => {
      updateTimelinePadding();
      positionJumpButton();
      updateJumpButton();
    };

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleOrientationChange);

    document.addEventListener('click', (event) => {
      const btn = event.target.closest('#jump-to-latest');
      if (!btn) return;
      scrollToBottom({ force: true });
      state.autoScroll = true;
      toggleJumpButtonVisibility(false);
    });

    document.addEventListener('click', (event) => {
      const trigger = event.target.closest('.tool-chip-trigger');
      if (trigger) {
        event.preventDefault();
        const chip = trigger.closest('.tool-chip');
        openToolChipDetail(chip);
        return;
      }

      const closeBtn = event.target.closest('.tool-chip-close');
      if (closeBtn) {
        event.preventDefault();
        closeOpenToolChip({ restoreFocus: true });
        return;
      }

      if (
        openToolChip &&
        !event.target.closest('.tool-chip') &&
        !event.target.closest('.tool-cluster-detail-host')
      ) {
        closeOpenToolChip();
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && openToolChip) {
        closeOpenToolChip({ restoreFocus: true });
      }
    });

    if (composer) {
      const scheduleComposerLayoutUpdate = () => window.requestAnimationFrame(() => {
        updateTimelinePadding();
        positionJumpButton();
        updateJumpButton();
      });

      let resizeComposerTextarea = null;

      composer.addEventListener('htmx:beforeRequest', () => {
        state.pendingComposerScroll = true;
      });
      composer.addEventListener('htmx:afterRequest', (event) => {
        if (event.detail && event.detail.xhr && event.detail.xhr.status < 400) {
          composer.reset();
          if (typeof resizeComposerTextarea === 'function') {
            resizeComposerTextarea({ reset: true });
            scheduleComposerLayoutUpdate();
          } else {
            scheduleComposerLayoutUpdate();
          }
          showProcessingIndicator({ sticky: true });
        } else {
          state.pendingComposerScroll = false;
        }
      });

      const composerTextarea = composer.querySelector('textarea');
      if (composerTextarea) {
        const MAX_COMPOSER_HEIGHT = 320;

        resizeComposerTextarea = ({ reset = false } = {}) => {
          if (reset) {
            composerTextarea.style.height = '';
          }
          composerTextarea.style.height = 'auto';
          const newHeight = Math.min(composerTextarea.scrollHeight, MAX_COMPOSER_HEIGHT);
          composerTextarea.style.height = `${newHeight}px`;
          composerTextarea.style.overflowY = composerTextarea.scrollHeight > MAX_COMPOSER_HEIGHT ? 'auto' : 'hidden';
        };

        const refreshComposerLayout = () => {
          resizeComposerTextarea();
          scheduleComposerLayoutUpdate();
        };

        refreshComposerLayout();

        composerTextarea.addEventListener('input', refreshComposerLayout);
        composerTextarea.addEventListener('focus', refreshComposerLayout);
        composerTextarea.addEventListener('blur', scheduleComposerLayoutUpdate);
        composerTextarea.addEventListener('keydown', (event) => {
          const isPlainEnter = event.key === 'Enter' && !event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey;
          if (!isPlainEnter || event.isComposing) {
            return;
          }
          event.preventDefault();
          composer.requestSubmit();
        });
      }
    }

    window.htmx.on('htmx:beforeRequest', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      closeOpenToolChip();
      const url = event.detail.requestConfig?.path || '';
      if (url.includes('direction=older')) {
        state.action = 'older';
        state.previousScrollHeight = timeline?.scrollHeight || 0;
      } else if (url.includes('direction=newer')) {
        state.action = 'newer';
      }
    });

    // Preserve the user's bottom offset while new timeline fragments stream in.
    window.htmx.on('htmx:beforeSwap', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      if (!timeline || state.action !== 'newer') {
        state.bottomAnchorOffset = null;
        state.pageBottomOffset = null;
        return;
      }

      const bottomOffset = getTimelineBottomOffset();
      const maintainAnchor = state.autoScroll || bottomOffset <= BOTTOM_ANCHOR_THRESHOLD;

      if (maintainAnchor) {
        state.bottomAnchorOffset = Math.max(bottomOffset, 0);
        state.pageBottomOffset = Math.max(getPageBottomOffset(), 0);
      } else {
        state.bottomAnchorOffset = null;
        state.pageBottomOffset = null;
      }
    });

    window.htmx.on('htmx:afterSwap', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;

      closeOpenToolChip();

      const anchorOffset = typeof state.bottomAnchorOffset === 'number' ? state.bottomAnchorOffset : null;
      const pageOffset = typeof state.pageBottomOffset === 'number' ? state.pageBottomOffset : null;
      state.bottomAnchorOffset = null;
      state.pageBottomOffset = null;

      ensureProcessingSlotPosition();
      updateTimelinePadding();

      if (state.action === 'newer' && anchorOffset !== null) {
        const target = Math.max(timeline.scrollHeight - timeline.clientHeight - anchorOffset, 0);
        if (typeof timeline.scrollTo === 'function') {
          timeline.scrollTo({ top: target, behavior: 'auto' });
        } else {
          timeline.scrollTop = target;
        }
      }

      if (state.action === 'newer' && pageOffset !== null) {
        scrollPageToBottomOffset(pageOffset, 'auto');
      }

      if (state.action === 'older' && timeline) {
        const delta = timeline.scrollHeight - state.previousScrollHeight;
        timeline.scrollTop = Math.max(delta, 0);
      }

      dedupeTimeline();
      trimTimeline(state.action);
      syncKnownCursors({ animate: state.action === 'newer' });
      updateComposerCursor();

      if (typeof Prism !== 'undefined') {
        Prism.highlightAllUnder(timeline);
      }

      if (state.autoScroll) {
        scrollToBottom({ force: true });
      }

      if (state.action === 'newer' || state.fetchingNewer) {
        completeNewerRequest();
      }

      state.action = 'idle';
      state.previousScrollHeight = 0;
      state.pendingComposerScroll = false;
      state.autoScroll = isNearBottom();
      updateJumpButton();
      refreshEmptyState();
      syncProcessingFromDom();
    });

    window.htmx.on('htmx:afterSettle', (event) => {
      if (event.detail?.target?.id === 'timeline-events') {
        ensureProcessingSlotPosition();
        updateTimelinePadding();
        updateJumpButton();
        refreshEmptyState();
        syncProcessingFromDom();
      }
    });

    window.htmx.on('htmx:responseError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      completeNewerRequest();
    });

    window.htmx.on('htmx:sendError', (event) => {
      if (event.detail?.target?.id !== 'timeline-events') return;
      completeNewerRequest();
    });

    const handleProcessingStartedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      showProcessingIndicator({ sticky: true });
    };

    const handleProcessingFinishedEvent = (evt) => {
      if (evt?.lastEventId) {
        state.lastEventId = evt.lastEventId;
      }
      reconnectDelay = 3000;
      hideProcessingIndicator();
      requestNewer('processing-finished');
    };

    function connectEventStream(lastId) {
      if (!eventStreamUrl) {
        console.warn('[agent-workspace] Missing eventStreamUrl dataset attribute; realtime updates disabled.');
        return;
      }

      if (typeof window.EventSource === 'undefined') {
        console.warn('[agent-workspace] EventSource API unavailable; realtime updates disabled.');
        return;
      }

      let cursor = lastId;
      if (cursor && !/^[0-9]+-[0-9]+$/.test(cursor)) {
        cursor = null;
      }

      const url = cursor ? `${eventStreamUrl}?cursor=${encodeURIComponent(cursor)}` : eventStreamUrl;
      const source = new EventSource(url);

      source.onopen = () => {
      };

      const handleMessage = (evt) => {
        if (evt.lastEventId) {
          state.lastEventId = evt.lastEventId;
        }
        reconnectDelay = 3000;
        requestNewer('auto-newer');
      };

      source.addEventListener('message', handleMessage);
      source.addEventListener('step.created', handleMessage);
      source.addEventListener('message.created', handleMessage);
      source.addEventListener('processing.started', handleProcessingStartedEvent);
      source.addEventListener('processing.finished', handleProcessingFinishedEvent);
      source.onerror = (err) => {
        source.close();
        state.eventSource = null;
        reconnectDelay = Math.min(Math.round(reconnectDelay * 1.5), RECONNECT_MAX);
        window.setTimeout(() => connectEventStream(state.lastEventId), reconnectDelay);
        hideProcessingIndicator();
      };

      state.eventSource = source;
    }

    ensureProcessingSlotPosition();
    syncProcessingFromDom();
    syncKnownCursors({ animate: false });
    connectEventStream(null);
    updateTimelinePadding();
    positionJumpButton();
    scrollToBottom({ force: true, behavior: 'auto', pageBehavior: 'auto' });
    updateJumpButton();
    refreshEmptyState();

    if (typeof Prism !== 'undefined') {
      Prism.highlightAllUnder(timeline);
    }

    window.addEventListener('beforeunload', () => {
      window.removeEventListener('scroll', handleWindowScroll);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleOrientationChange);
      if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
      }
    });
  }

  ready();
})();
</script>
{% endblock %}
