<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Agent Audit Export - {{ agent_name }}</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #ffffff;
      --ink: #0b1220;
      --ink-soft: #334155;
      --accent: #0ea5e9;
      --accent-soft: #e0f2fe;
      --message-soft: #dcfce7;
      --message-ink: #047857;
      --completion-soft: #dbeafe;
      --completion-ink: #1d4ed8;
      --tool-soft: #fef3c7;
      --tool-ink: #a16207;
      --warn: #b91c1c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(1200px 600px at 10% -20%, #1d4ed8 0%, transparent 45%), var(--bg);
      color: var(--ink);
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    .header {
      border-radius: 16px;
      background: linear-gradient(135deg, #082f49, #0f766e);
      color: #f8fafc;
      padding: 18px 20px;
      box-shadow: 0 16px 30px rgba(2, 8, 23, 0.35);
    }

    .header h1 {
      margin: 0;
      font-size: 22px;
      line-height: 1.2;
    }

    .header p {
      margin: 10px 0 0;
      opacity: 0.9;
      font-size: 14px;
    }

    .controls {
      margin-top: 14px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .controls label {
      font-size: 13px;
      opacity: 0.95;
    }

    .controls select {
      margin-left: 8px;
      border: 0;
      border-radius: 8px;
      padding: 7px 10px;
      font-size: 13px;
      background: #f8fafc;
      color: #0f172a;
    }

    .panel {
      margin-top: 20px;
      border-radius: 16px;
      background: var(--panel);
      padding: 14px;
      box-shadow: 0 16px 30px rgba(2, 8, 23, 0.22);
      min-height: 240px;
    }

    .panel h2 {
      margin: 0 0 12px;
      color: var(--ink);
      font-size: 17px;
    }

    .counts {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .count {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #0369a1;
      font-size: 12px;
      font-weight: 600;
      padding: 4px 10px;
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .empty {
      color: var(--ink-soft);
      font-size: 14px;
      margin: 0;
    }

    .card {
      border: 1px solid #bae6fd;
      border-radius: 12px;
      padding: 10px 12px;
      background: #f0f9ff;
    }

    .card.message {
      border-color: #86efac;
      background: #f0fdf4;
    }

    .card.completion {
      border-color: #93c5fd;
      background: #eff6ff;
    }

    .card-head {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .card-title {
      margin: 0;
      font-size: 14px;
      color: var(--ink);
      font-weight: 700;
    }

    .stamp {
      margin: 0;
      font-size: 12px;
      color: #075985;
      font-weight: 600;
    }

    .meta {
      margin-top: 8px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .pill {
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
      padding: 4px 8px;
      background: #dbeafe;
      color: #1d4ed8;
    }

    .pill.message {
      background: var(--message-soft);
      color: var(--message-ink);
    }

    .pill.completion {
      background: var(--completion-soft);
      color: var(--completion-ink);
    }

    .pill.tool {
      background: var(--tool-soft);
      color: var(--tool-ink);
    }

    details {
      margin-top: 8px;
      border-radius: 8px;
      background: #ffffff;
      border: 1px solid #bae6fd;
      padding: 8px 9px;
    }

    details > summary {
      cursor: pointer;
      font-size: 13px;
      color: var(--ink);
      font-weight: 600;
      list-style: none;
    }

    .summary-row {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .copy-btn {
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      color: #0f172a;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 700;
      padding: 2px 6px;
      cursor: pointer;
      line-height: 1.2;
    }

    .copy-btn:hover {
      border-color: #94a3b8;
      background: #f1f5f9;
    }

    details > summary::-webkit-details-marker {
      display: none;
    }

    details > summary::after {
      content: " +";
      color: #0369a1;
      font-weight: 700;
    }

    details[open] > summary::after {
      content: " -";
    }

    pre {
      margin: 8px 0 0;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      background: #f8fafc;
      border-radius: 8px;
      padding: 8px;
      color: var(--ink);
      font-size: 12px;
      line-height: 1.35;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .html-body {
      margin-top: 8px;
      border-radius: 8px;
      padding: 10px;
      background: #ffffff;
      border: 1px solid #bbf7d0;
      color: #052e16;
      font-size: 13px;
      line-height: 1.45;
      overflow-wrap: anywhere;
    }

    .html-body p,
    .html-body ul,
    .html-body ol,
    .html-body pre,
    .html-body blockquote {
      margin-top: 0;
      margin-bottom: 10px;
    }

    .html-body :last-child {
      margin-bottom: 0;
    }

    .tool-call {
      margin-top: 8px;
      border-radius: 10px;
      background: #ffffff;
      border: 1px solid #fde68a;
      padding: 8px;
    }

    .tool-call h4 {
      margin: 0;
      font-size: 13px;
      color: #7c2d12;
    }

    .tool-call p {
      margin: 5px 0 0;
      font-size: 11px;
      color: #9a3412;
      font-weight: 600;
    }

    .warn {
      margin-top: 8px;
      font-size: 12px;
      color: var(--warn);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="header">
      <h1>Agent Audit Export - {{ agent_name }}</h1>
      <p id="summary-line">Generated {{ generated_at|default:"(unknown)" }}.</p>
      <div class="controls">
        <label>
          Sort by timestamp
          <select id="sort-order">
            <option value="desc">Newest first</option>
            <option value="asc">Oldest first</option>
          </select>
        </label>
      </div>
    </section>

    <section class="panel">
      <h2>Unified Timeline</h2>
      <div class="counts" id="timeline-counts"></div>
      <div class="list" id="timeline-list"></div>
    </section>
  </main>

  <script id="audit-data-b64" type="text/plain">{{ payload_b64 }}</script>
  <script>
    function decodeBase64Utf8(base64Text) {
      const binary = atob(base64Text);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new TextDecoder().decode(bytes);
    }

    function toText(value) {
      if (value === null || value === undefined) return "";
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value, null, 2);
      } catch (error) {
        return String(value);
      }
    }

    function parseTime(value) {
      const ts = Date.parse(value || "");
      return Number.isNaN(ts) ? 0 : ts;
    }

    function formatTime(value) {
      if (!value) return "(no timestamp)";
      const ts = Date.parse(value);
      if (Number.isNaN(ts)) return value;
      return new Date(ts).toLocaleString();
    }

    function sortByTimestamp(items, order) {
      const direction = order === "asc" ? 1 : -1;
      return items.slice().sort((left, right) => {
        const leftTime = parseTime(left.timestamp);
        const rightTime = parseTime(right.timestamp);
        if (leftTime === rightTime) {
          return String(left.id || "").localeCompare(String(right.id || ""));
        }
        return (leftTime - rightTime) * direction;
      });
    }

    function makePill(text, className) {
      const span = document.createElement("span");
      span.className = className ? "pill " + className : "pill";
      span.textContent = text;
      return span;
    }

    function makePre(label, value) {
      const wrapper = document.createElement("details");
      const summary = document.createElement("summary");
      summary.textContent = label;
      wrapper.appendChild(summary);
      const pre = document.createElement("pre");
      pre.textContent = toText(value);
      wrapper.appendChild(pre);
      return wrapper;
    }

    async function copyTextToClipboard(text) {
      const content = toText(text);
      if (!content) return false;
      if (!navigator.clipboard || typeof navigator.clipboard.writeText !== "function") {
        return false;
      }
      try {
        await navigator.clipboard.writeText(content);
        return true;
      } catch (error) {
        return false;
      }
    }

    function makeCopyablePromptPre(label, value) {
      const wrapper = document.createElement("details");
      const summary = document.createElement("summary");
      const row = document.createElement("span");
      row.className = "summary-row";

      const text = document.createElement("span");
      text.textContent = label;
      row.appendChild(text);

      const copyButton = document.createElement("button");
      copyButton.type = "button";
      copyButton.className = "copy-btn";
      copyButton.textContent = "Copy";
      copyButton.setAttribute("aria-label", "Copy " + label);
      copyButton.addEventListener("click", async (event) => {
        event.preventDefault();
        event.stopPropagation();
        const copied = await copyTextToClipboard(value);
        const resetText = copied ? "Copied" : "Copy failed";
        copyButton.textContent = resetText;
        window.setTimeout(() => {
          copyButton.textContent = "Copy";
        }, 1200);
      });
      row.appendChild(copyButton);

      summary.appendChild(row);
      wrapper.appendChild(summary);

      const pre = document.createElement("pre");
      pre.textContent = toText(value);
      wrapper.appendChild(pre);
      return wrapper;
    }

    function sanitizeHtml(html) {
      if (!html || typeof html !== "string") return "";
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");

      doc.querySelectorAll("script,style,iframe,object,embed,link,meta").forEach((node) => node.remove());

      doc.querySelectorAll("*").forEach((el) => {
        Array.from(el.attributes).forEach((attr) => {
          const name = attr.name.toLowerCase();
          const value = (attr.value || "").trim();
          if (name.startsWith("on")) {
            el.removeAttribute(attr.name);
            return;
          }
          if ((name === "href" || name === "src") && value.toLowerCase().startsWith("javascript:")) {
            el.removeAttribute(attr.name);
          }
        });
      });

      return doc.body.innerHTML || "";
    }

    function renderCounts(counts, total) {
      const container = document.getElementById("timeline-counts");
      container.innerHTML = "";
      container.appendChild(makePill("Total: " + total));
      container.appendChild(makePill("Completions: " + (counts.completions || 0), "completion"));
      container.appendChild(makePill("Messages: " + (counts.messages || 0), "message"));
    }

    function renderCompletionCard(item) {
      const completion = item.data;
      const card = document.createElement("article");
      card.className = "card completion";

      const head = document.createElement("div");
      head.className = "card-head";

      const title = document.createElement("h3");
      title.className = "card-title";
      const model = completion.llm_model || "Unknown model";
      const provider = completion.llm_provider || "provider";
      title.textContent = "Completion - " + model + " (" + provider + ")";
      head.appendChild(title);

      const stamp = document.createElement("p");
      stamp.className = "stamp";
      stamp.textContent = formatTime(completion.timestamp);
      head.appendChild(stamp);
      card.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.appendChild(makePill("Completion", "completion"));
      meta.appendChild(makePill("Type: " + (completion.completion_type || "other"), "completion"));
      if (completion.prompt_tokens !== null && completion.prompt_tokens !== undefined) {
        meta.appendChild(makePill("Prompt: " + completion.prompt_tokens));
      }
      if (completion.completion_tokens !== null && completion.completion_tokens !== undefined) {
        meta.appendChild(makePill("Output: " + completion.completion_tokens));
      }
      if (completion.total_tokens !== null && completion.total_tokens !== undefined) {
        meta.appendChild(makePill("Total: " + completion.total_tokens));
      }
      if (completion.response_id) {
        meta.appendChild(makePill("Response: " + completion.response_id));
      }
      card.appendChild(meta);

      const promptArchive = completion.prompt_archive || null;
      const promptPayload = promptArchive && promptArchive.payload ? promptArchive.payload : null;
      if (promptPayload) {
        if (promptPayload.system_prompt) {
          card.appendChild(makeCopyablePromptPre("System prompt", promptPayload.system_prompt));
        }
        if (promptPayload.user_prompt) {
          card.appendChild(makeCopyablePromptPre("User prompt", promptPayload.user_prompt));
        }
        if (promptPayload.error) {
          const warn = document.createElement("div");
          warn.className = "warn";
          warn.textContent = "Prompt payload unavailable: " + promptPayload.error;
          card.appendChild(warn);
        }
      }

      if (completion.thinking) {
        card.appendChild(makePre("Thinking content", completion.thinking));
      }

      const toolCalls = Array.isArray(completion.tool_calls) ? completion.tool_calls : [];
      if (toolCalls.length) {
        const sortedTools = sortByTimestamp(toolCalls, document.getElementById("sort-order").value || "desc");
        sortedTools.forEach((tool) => {
          const toolCard = document.createElement("section");
          toolCard.className = "tool-call";

          const toolName = document.createElement("h4");
          toolName.textContent = tool.tool_name || "Tool call";
          toolCard.appendChild(toolName);

          const toolTime = document.createElement("p");
          toolTime.textContent = formatTime(tool.timestamp);
          toolCard.appendChild(toolTime);

          const toolMeta = document.createElement("div");
          toolMeta.className = "meta";
          toolMeta.appendChild(makePill("Tool call", "tool"));
          if (tool.execution_duration_ms !== null && tool.execution_duration_ms !== undefined) {
            toolMeta.appendChild(makePill("Duration: " + tool.execution_duration_ms + " ms", "tool"));
          }
          toolCard.appendChild(toolMeta);

          toolCard.appendChild(makePre("Parameters", tool.parameters));
          toolCard.appendChild(makePre("Result", tool.result));

          card.appendChild(toolCard);
        });
      }

      return card;
    }

    function renderMessageCard(item) {
      const message = item.data;
      const card = document.createElement("article");
      card.className = "card message";

      const head = document.createElement("div");
      head.className = "card-head";

      const title = document.createElement("h3");
      title.className = "card-title";
      const direction = message.is_outbound ? "Message - Agent to User" : "Message - User to Agent";
      title.textContent = direction;
      head.appendChild(title);

      const stamp = document.createElement("p");
      stamp.className = "stamp";
      stamp.textContent = formatTime(message.timestamp);
      head.appendChild(stamp);

      card.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.appendChild(makePill("Message", "message"));
      meta.appendChild(makePill("Channel: " + (message.channel || "web"), "message"));
      if (message.id) {
        meta.appendChild(makePill("Message: " + message.id, "message"));
      }
      card.appendChild(meta);

      const htmlBody = typeof message.body_html === "string" ? message.body_html.trim() : "";
      if (htmlBody) {
        const htmlSection = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = "Body";
        htmlSection.appendChild(summary);

        const body = document.createElement("div");
        body.className = "html-body";
        body.innerHTML = sanitizeHtml(htmlBody);
        htmlSection.appendChild(body);
        card.appendChild(htmlSection);
      } else {
        const bodyText = message.body_text || "";
        if (bodyText) {
          card.appendChild(makePre("Body", bodyText));
        }
      }

      const attachments = Array.isArray(message.attachments) ? message.attachments : [];
      if (attachments.length) {
        const attachmentLines = attachments.map((attachment) => {
          const name = attachment.filespace_path || attachment.filename || "attachment";
          const size = attachment.file_size_label ? " (" + attachment.file_size_label + ")" : "";
          return name + size;
        });
        card.appendChild(makePre("Attachments", attachmentLines.join("\n")));
      }

      return card;
    }

    function buildTimelineItems(data) {
      const items = [];
      const completions = Array.isArray(data.completions) ? data.completions : [];
      const messages = Array.isArray(data.messages) ? data.messages : [];

      completions.forEach((completion) => {
        items.push({
          kind: "completion",
          id: completion.id,
          timestamp: completion.timestamp,
          data: completion,
        });
      });

      messages.forEach((message) => {
        items.push({
          kind: "message",
          id: message.id,
          timestamp: message.timestamp,
          data: message,
        });
      });

      return items;
    }

    function renderTimeline(data) {
      const list = document.getElementById("timeline-list");
      list.innerHTML = "";

      const order = (document.getElementById("sort-order").value || "desc");
      const items = sortByTimestamp(buildTimelineItems(data), order);

      renderCounts(data.counts || {}, items.length);

      if (!items.length) {
        const empty = document.createElement("p");
        empty.className = "empty";
        empty.textContent = "No completion or message events found in this export.";
        list.appendChild(empty);
        return;
      }

      items.forEach((item) => {
        if (item.kind === "completion") {
          list.appendChild(renderCompletionCard(item));
        } else if (item.kind === "message") {
          list.appendChild(renderMessageCard(item));
        }
      });
    }

    const payloadText = document.getElementById("audit-data-b64").textContent || "";
    const decoded = decodeBase64Utf8(payloadText.trim());
    const auditData = JSON.parse(decoded);

    const summary = document.getElementById("summary-line");
    if (summary) {
      const exportedAt = formatTime(auditData.exported_at);
      const completionCount = auditData.counts && auditData.counts.completions ? auditData.counts.completions : 0;
      const messageCount = auditData.counts && auditData.counts.messages ? auditData.counts.messages : 0;
      summary.textContent = "Generated " + exportedAt + " - " + completionCount + " completions - " + messageCount + " messages";
    }

    renderTimeline(auditData);

    const orderSelect = document.getElementById("sort-order");
    if (orderSelect) {
      orderSelect.addEventListener("change", () => renderTimeline(auditData));
    }
  </script>
</body>
</html>
